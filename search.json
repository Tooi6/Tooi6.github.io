[{"title":"Linux 基础 & LVM 磁盘扩容","url":"/2019/11/02/Linux 基础 & LVM 磁盘扩容/","content":"\n### 下载、安装Ubuntu  \n> 官网下载：https://ubuntu.com/download/server  \n\n### Linux目录结构  \n\n| 目录   | 说明                                       |\n|------|------------------------------------------|\n| **bin**  | 存放二进制可执行文件\\(ls,cat,mkdir等\\)              |\n| boot | 存放用于系统引导时使用的各种文件                         |\n| dev  | 用于存放设备文件                                 |\n| **etc**  | 存放系统配置文件                                 |\n| **home** | 存放所有用户文件的根目录                             |\n| lib  | 存放跟文件系统中的程序运行所需要的共享库及内核模块                |\n| mnt  | 系统管理员安装临时文件系统的安装点                        |\n| opt  | 额外安装的可选应用程序包所放置的位置                       |\n| proc | 虚拟文件系统，存放当前内存的映射                         |\n| root | 超级用户目录                                   |\n| sbin | 存放二进制可执行文件，只有root才能访问                    |\n| tmp  | 用于存放各种临时文件                               |\n| **usr**  | 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 |\n| **var**  | 用于存放运行时需要改变数据的文件                         |\n\n### 修改数据源  \n\n```\n# 查看系统版本\nlsb_release -a\n# 编辑数据源  \nvi /etc/apt/sources.list\n## 删除全部内容，添加  \ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\n# 更新数据源\napt-get update\n```\n\n### LVM的基本概念  \n#### 物理卷 Physical volume（PV）\n> 可以在上面建立卷组的媒介，可以是**硬盘分区**，也可以是**硬盘本身**或者**回环文件**（loopback file）。物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents）  \n\n#### 卷组 Volume group (VG)  \n> 将一组物理卷收集为一个**管理单元**  \n\n#### 逻辑卷 Logical volume (LV)  \n> **虚拟分区**，由物理区域（physical extents）组成  \n\n#### 物理区域 Physical extent (PE)\n> 硬盘可供指派给逻辑卷的最小单位（通常为 4MB）  \n\n### 开始LVM扩容  \n\n```\n# 查看 fdisk\nfdisk -l  \n```\n\n![image](https://note.youdao.com/yws/api/personal/file/158366A2ECF241F38EF67284942E1B67?method=download&shareKey=03efad7f6657df0955557c96be683842)\n\n> 因为这台机器默认开启了 LVM，所以目前有一个 **extended** 分区和一个 **LVM** 分区，并且他们是完全重叠的。这是因为，LVM 分区作为一个虚拟的分区，完全占用了这个 extended 分区，原理图见下：  \n![image](https://note.youdao.com/yws/api/personal/file/4641A2265CDD4FCAA12DD369E1F9B6E3?method=download&shareKey=bb9a1f1d593a7653ab75f0d108755840)  \n> 因此，现在需要做的就是将 extended partition (sda2) 扩展到最大，然后创建一个新的 LVM logical partition (sda6)，用它来填满 sda2  \n\n#### 查看所有连接到电脑上的储存设备  \n\n```\nfdisk -l |grep '/dev'\n```\n\n**1 块磁盘效果图**  \n![image](https://note.youdao.com/yws/api/personal/file/E01530FE7C014C08B037D8757099FA4B?method=download&shareKey=109c7985d3cfdeca6dec59c97c58f3fb)\n\n**2 块磁盘效果图**\n![image](https://note.youdao.com/yws/api/personal/file/474A8AA4FF1442CF948E14453A3BD1CB?method=download&shareKey=2f3b44b4c0ce214376481b1ed57cba36)\n\n#### 创建 sdb 分区  \n\n```\nfdisk /dev/sdb\nn\t# 新建分区\nl\t# 选择逻辑分区，如果没有，则首先创建扩展分区（p），然后再添加逻辑分区（硬盘：最多四个分区 P-P-P-P 或 P-P-P-E）\n# 格式化磁盘  \nmkfs -t ext4 /dev/sdb1\n# 创建 PV  \npvcreate /dev/sdb1\n# 查看卷组\npvscan\n# 扩容 VG\nvgdisplay\nvgextend ubuntu-vg /dev/sdb1\n# 增加指定大小\nlvextend -L +30G /dev/ubuntu-vg/root\n# 按百分比扩容\nlvextend -l +100%FREE /dev/ubuntu-vg/root\n# 刷新分区\nresize2fs /dev/ubuntu-vg/root\n# 删除 unknown device\npvscan\nvgreduce --removemissing ubuntu-vg\n```\n\n\n","tags":["Linux","Ubuntu","LVM"]},{"title":"GitFlow 工作流","url":"/2019/10/30/GitFlow 工作流/","content":"### Tortoise Git  \n> 官网下载：https://tortoisegit.org/download/  \n\n### Git几种主流的工作流\n#### 集中式工作流  \n> 所有的**功能开发与修改都在 master 分支上进行**的。开发者开始先克隆中央仓库。在自己的项目拷贝中像SVN一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。  \n![image](https://note.youdao.com/yws/api/personal/file/64CEFF1425774282A82F1E00D0FA8649?method=download&shareKey=5833170a020b4bb4651c41f983e47b37)  \n\n#### 功能分支工作流  \n> 功能分支工作流以集中式工作流为基础，不同的是**为各个新功能分配一个专门的分支来开发**。功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在 master 分支上。  \n![image](https://note.youdao.com/yws/api/personal/file/B1701B5FAB8140FEA44B3AD7372F114E?method=download&shareKey=c879c215afd63fdabfb4884b11cb9124)  \n\n#### GitFlow 工作流  \n> GitFlow 工作流通过为**功能开发、发布准备**和**维护分配**独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。\n![image](https://note.youdao.com/yws/api/personal/file/FB06F01E87C044949FABB9CDDE711F87?method=download&shareKey=a8fe1902c3daa4a33ea992469f5fa276)\n\n#### Forking 工作流  \n> Forking 工作流是分布式工作流，充分利用了 Git 在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。  \n![image](https://note.youdao.com/yws/api/personal/file/C89D9EEB7E08493380A8964FE4424739?method=download&shareKey=432315df4ddd4ba6ae44d3ee9af5724a)\n\n#### 流程解析  \n\n- **master分支：** 存放所有**正式发布的版本**，可以作为项目**历史版本记录分支**，不直接提交代码。仅用于保持一个对应线上运行代码的 code base。\n- **develop分支：** 为**主开发分支**，一般不直接提交代码  \n- **feature分支：** 为**新功能分支**，feature分支都是基于develop创建的，开发完成后会合并到develop分支上。\n- **release分支：** 为**发布分支**，基于最新develop分支创建。\n- **hotfix分支：** **基于master分支创建**，对线上版本的**bug进行修复**，完成后直接合并到master分支和develop分支，如果当前还有新功能release分支，也同步到release分支上。","tags":["GitFlow 工作流","Tortoise Git"]},{"title":"Validation（jQuery+Spring）","url":"/2019/10/28/Validation（jQuery+Spring）/","content":"\n### jQuery Validation  \n> jQuery Validation 前端表单验证框架  \n下载：https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.1    \n官方文档：https://jqueryvalidation.org/documentation/  \n\n#### DEMO  \n> 来源：https://www.runoob.com/jquery/jquery-plugin-validate.html\n\n```\n#引入js  \n<!-- jQuery Validation 1.14.0 -->\n<script src=\"../assets/jquery-validation-1.14.0/lib/jquery.js\"></script>\n<script src=\"../assets/jquery-validation-1.14.0/dist/jquery.validate.min.js\"></script>\n<script src=\"../assets/jquery-validation-1.14.0/dist/localization/messages_zh.js\"></script>\n\n#初始化脚本\n<script>\n$.validator.setDefaults({\n    submitHandler: function() {\n      alert(\"提交事件!\");\n    }\n});\n$().ready(function() {\n    $(\"#commentForm\").validate();\n});\n</script>\n\n#引入规则\n<form class=\"cmxform\" id=\"commentForm\" method=\"get\" action=\"\">\n  <fieldset>\n    <legend>输入您的名字，邮箱，URL，备注。</legend>\n    <p>\n      <label for=\"cname\">Name (必需, 最小两个字母)</label>\n      <input id=\"cname\" name=\"name\" minlength=\"2\" type=\"text\" required>\n    </p>\n    <p>\n      <label for=\"cemail\">E-Mail (必需)</label>\n      <input id=\"cemail\" type=\"email\" name=\"email\" required>\n    </p>\n    <p>\n      <label for=\"curl\">URL (可选)</label>\n      <input id=\"curl\" type=\"url\" name=\"url\">\n    </p>\n    <p>\n      <label for=\"ccomment\">备注 (必需)</label>\n      <textarea id=\"ccomment\" name=\"comment\" required></textarea>\n    </p>\n    <p>\n      <input class=\"submit\" type=\"submit\" value=\"Submit\">\n    </p>\n  </fieldset>\n</form>\n```\n\n### Spring Validation  \n> 官方文档：https://spring.io/guides/gs/validating-form-input/  \n\n#### DEMO  \n\n```\n#pom.xml  \n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>5.3.4.Final</version>\n</dependency>\n\n#定义工具类\n/**\n * JSR303 Validator(Hibernate Validator)工具类.\n * <p>\n * ConstraintViolation 中包含 propertyPath, message 和 invalidValue 等信息.\n * 提供了各种 convert 方法，适合不同的 i18n 需求:\n * 1. List<String>, String 内容为 message\n * 2. List<String>, String 内容为 propertyPath + separator + message\n * 3. Map<propertyPath, message>\n * <p>\n * 详情见wiki: https://github.com/springside/springside4/wiki/HibernateValidator\n *\n * <p>Title: BeanValidator</p>\n * <p>Description: </p>\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/26 17:21\n */\npublic class BeanValidator {\n\n    @Autowired\n    private static Validator validator;\n\n    public static void setValidator(Validator validator) {\n        BeanValidator.validator = validator;\n    }\n\n    /**\n     * 调用 JSR303 的 validate 方法, 验证失败时抛出 ConstraintViolationException.\n     */\n    private static void validateWithException(Validator validator, Object object, Class<?>... groups) throws ConstraintViolationException {\n        Set constraintViolations = validator.validate(object, groups);\n        if (!constraintViolations.isEmpty()) {\n            throw new ConstraintViolationException(constraintViolations);\n        }\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 中为 List<message>.\n     */\n    private static List<String> extractMessage(ConstraintViolationException e) {\n        return extractMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 List<message>\n     */\n    private static List<String> extractMessage(Set<? extends ConstraintViolation> constraintViolations) {\n        List<String> errorMessages = new ArrayList<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 Map<property, message>.\n     */\n    private static Map<String, String> extractPropertyAndMessage(ConstraintViolationException e) {\n        return extractPropertyAndMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 Map<property, message>.\n     */\n    private static Map<String, String> extractPropertyAndMessage(Set<? extends ConstraintViolation> constraintViolations) {\n        Map<String, String> errorMessages = new HashMap<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.put(violation.getPropertyPath().toString(), violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 List<propertyPath message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(ConstraintViolationException e) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), \" \");\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolations> 为 List<propertyPath message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(Set<? extends ConstraintViolation> constraintViolations) {\n        return extractPropertyAndMessageAsList(constraintViolations, \" \");\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 List<propertyPath + separator + message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(ConstraintViolationException e, String separator) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), separator);\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 List<propertyPath + separator + message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(Set<? extends ConstraintViolation> constraintViolations, String separator) {\n        List<String> errorMessages = new ArrayList<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getPropertyPath() + separator + violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 服务端参数有效性验证\n     *\n     * @param object 验证的实体对象\n     * @param groups 验证组\n     * @return 验证成功：返回 null；验证失败：返回错误信息\n     */\n    public static String validator(Object object, Class<?>... groups) {\n        try {\n            validateWithException(validator, object, groups);\n        } catch (ConstraintViolationException ex) {\n            List<String> list = extractMessage(ex);\n            list.add(0, \"数据验证失败：\");\n\n            // 封装错误消息为字符串\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < list.size(); i++) {\n                String exMsg = list.get(i);\n                if (i != 0 ){\n                    sb.append(String.format(\"%s. %s\", i, exMsg)).append(list.size() > 1 ? \"<br/>\" : \"\");\n                } else {\n                    sb.append(exMsg).append(list.size() > 1 ? \"<br/>\" : \"\");\n                }\n            }\n\n            return sb.toString();\n        }\n\n        return null;\n    }\n}\n\n#添加注解  \n@Length(min = 6, max = 20, message = \"用户名长度必须介于 6 和 20 之间\")\nprivate String username;\n\n#xml注入工具类 \n<!-- 配置 Bean Validator 定义 -->\n<bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/>\n<bean id=\"beanValidator\" class=\"com.funtl.my.shop.commons.validator.BeanValidator\">\n    <property name=\"validator\" ref=\"validator\" />\n</bean>\n```\n","tags":["Validation","jQuery","Spring"]},{"title":"REST架构以及RESTful？","url":"/2019/10/28/REST架构以及RESTful？/","content":"### 介绍  \n#### 什么是REST？  \n> **REST（Representational State Transfer）** 表象化状态转变（表述性状态转变），在2000年被提出，基于HTTP、URI、XML、JSON等标准和协议，支持**轻量级、跨平台、跨语言**的架构设计。是Web服务的一种新的**架构风格**（一种思想）。 \n\n#### REST架构的主要原则  \n- 对网络上所有的资源都有一个**资源标志符**。\n- 对资源的操作**不会**改变标识符。\n- 同一资源有多种表现形式（xml、json）\n- 所有操作都是**无状态**的（Stateless） \n\n> **无状态性：** 使得客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前的请求，不需了解请求的历史。可以更容易的释放资源，让服务器利用Pool（连接池）技术来提高稳定性和性能。  \n\n#### 什么是RESTful风格？\n> RESTful是一种常见的**REST应用**，是遵循REST风格的**web服务**，REST式的web服务是一种ROA（面向资源的架构）。 \n\n### API设计  \n#### 设计原则  \n- URI 不能包含动词，只能是名词  \n> 形容词也是可以使用的，但是尽量少用  \n- API 的名词要以复数进行命名  \n- 命名名词的时候，要使用小写、数字及下划线来区分多个单词  \n> 样的设计是为了与 json 对象及属性的命名方案保持一致  \n#### 请求方式\n\n| http方法 | 资源操作   | 幂等 | 安全 |\n|--------|--------|----|----|\n| GET    | SELECT | 是  | 是  |\n| POST   | INSERT | 否  | 否  |\n| PUT    | UPDATE | 是  | 否  |\n| DELETE | DELETE | 是  | 否  |\n\n#### 状态码  \n\n| 状态码 | 描述      |\n|-----|---------|\n| 200 | 请求成功    |\n| 201 | 创建成功    |\n| 400 | 错误的请求   |\n| 401 | 未验证     |\n| 403 | 被拒绝     |\n| 404 | 无法找到    |\n| 409 | 资源冲突    |\n| 500 | 服务器内部错误 |\n\n#### 请求参数  \n- **对请求参数进行限制说明，写明参数要求**\n```\n【POST】     /v1/users                             // 创建用户信息\n请求内容\n{\n    \"username\": \"Tooi\",                 // 必填, 用户名称, max 20\n    \"password\": \"123456\",              // 必填, 用户密码, max 20\n    \"email\": \"tooi997@163.com\",     // 选填, 电子邮箱, max 32\n    \"sex\": 1                           // 必填, 用户性别[1-男 2-女 99-未知]\n}\n```\n\n#### 响应参数\n- **单条数据，直接返回json**\n\n```\nHTTP/1.1 200 OK\n{\n    \"id\" : \"01\",\n    \"name\" : \"Tooi6\",\n    \"created_time\": 2019-10-26,\n    \"updated_time\": 2019-10-26,\n    ...\n}\n```\n\n- 多条数据，封装结构体\n\n```\nHTTP/1.1 200 OK\n{\n    \"count\":100,\n    \"items\":[\n        {\n            \"id\" : \"01\",\n            \"name\" : \"Tooi6\",\n            \"created_time\": 2019-10-26,\n            \"updated_time\": 2019-10-26,\n            ...\n        },\n        ...\n    ]\n}\n```\n\n\n#### 异常响应  \n\n```\nHTTP/1.1 400 Bad Request\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n```  \n\n\n\n","tags":["RESTful","架构风格"]},{"title":"使用Hexo+Github搭建博客","url":"/2018/12/01/使用Hexo+Github搭建博客/","content":"\n### 准备工作  \n- 创建仓库，创建一个名为 <你的用户名>.github.io 的仓库  \n- 安装软件  \n\n```\n# 下载、安装、配置 git\n官网下载：https://www.git-scm.com/download/   \n## 配置ssh key\n\n# 下载、安装 node.js  \nhttps://nodejs.org/en/download/ \n\n# 安装 hexo  \nnpm install -g hexo  \n```\n\n### 开始搭建  \n\n```\n# 初始化（必须在空文件夹内，使用git bash运行）  \nhexo init \n# 清理生成内容\nhexo clean \n# 生成\nhexo g \n# 启动服务\nhexo s  \n\n# 修改主题\n## 到官网下载主题 https://hexo.io/themes/  \n## 下载后解压到 themes 目录下  \n## 修改配置文件_config.yml  \n- theme: landscape\n+ theme: suka  \n\n# 上传到github\n## 配置_config.yml中deploy部分\ndeploy:\n  type: git\n  repository: git@github.com:Tooi6/Tooi6.github.io.git\n  branch: master  \n## 安装插件（不安装提示Deployer not found: git错误）\nnpm install hexo-deployer-git --save\n## 上传\nhexo d\n```\n\n### 常用的hexo命令  \n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\n```\n","tags":["Hexo","Github"]}]