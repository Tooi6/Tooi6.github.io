[{"title":"Spring Boot 配置使用Swagger2","url":"/2019/12/01/Spring Boot 配置使用Swagger2/","content":"\n### 概述  \n> swagger2 是一个规范和完整的框架，用于生成、描述、调用和可视化Restful风格的web服务,缺点是代码植入性较强。  \n\n### Spring Boot 配置Swagger2  \n\n- **添加依赖**  \n\n```\n<!-- Swagger2 Begin -->\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger2</artifactId>\n    <version>2.8.0</version>\n</dependency>\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger-ui</artifactId>\n    <version>2.8.0</version>\n</dependency>\n<!-- Swagger2 End -->\n```\n\n- **配置Swagger2**  \n> 新建 Swagger2Config 配置类\n```\n@Configuration\npublic class Swagger2Config {\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.tooi.icoin.service.posts.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title(\"iCoin 文章服务文档\")\n                .description(\"icoin-service-posts\")\n                .termsOfServiceUrl(\"https://tooi6.github.io/\")\n                .version(\"1.0.0\")\n                .build();\n    }\n}\n```\n\n- **启用 Swagger2**  \n> Spring boot启动类添加 **@EnableSwagger2** 注解\n\n\n- **在Controller中使用Swagger注解**  \n> 在Controller方法上添加注解，用于说明接口  \n\n```\n@ApiOperation(value = \"文章分页查询\")\n@ApiImplicitParams({\n        @ApiImplicitParam(name = \"pageNum\", value = \"当前页码\", required = true, dataType = \"int\", paramType = \"path\"),\n        @ApiImplicitParam(name = \"pageSize\", value = \"每页条数\", required = true, dataType = \"int\", paramType = \"path\"),\n        @ApiImplicitParam(name = \"tbPostsPostJson\", value = \"查询条件，文章对象json字符串\", required = false, dataType = \"int\", paramType = \"json\")\n})\n```\n\n- **访问接口文档**  \n> http://ip:port/swagger-ui.html\n\n- **注解说明**\n\n```\n@Api：修饰整个类，描述 Controller 的作用\n@ApiOperation：描述一个类的一个方法，或者说一个接口\n@ApiParam：单个参数描述\n@ApiModel：用对象来接收参数\n@ApiProperty：用对象接收参数时，描述对象的一个字段\n@ApiResponse：HTTP 响应其中 1 个描述\n@ApiResponses：HTTP 响应整体描述\n@ApiIgnore：使用该注解忽略这个API\n@ApiError：发生错误返回的信息\n@ApiImplicitParam：一个请求参数\n@ApiImplicitParams：多个请求参数\n```\n\n","tags":["Swagger2"]},{"title":"使用Nginx实现 反向代理 & 负载均衡","url":"/2019/11/24/使用Nginx实现 反向代理 & 负载均衡/","content":"\n### 什么是 Nginx？  \n> Nginx 是一个很强大的高性能Web和反向代理服务,在连接高并发的情况下，Nginx是Apache服务不错的替代品。能够支持高达 50,000 个并发连接数的响应。\n\n### Nginx 的应用场景\n\n#### Http 代理（正向代理、反向代理）\n- **什么是代理服务器？**\n> 代理服务器，客户机在发送请求时，不会直接发送给目的主机，而是先发送给代理服务器，代理服务接受客户机请求之后，再向主机发出，并接收目的主机返回的数据，存放在代理服务器的硬盘中，再发送给客户机。  \n- **正向代理和反向代理？**  \n> **正向代理**，架设在客户机与目标主机之间，只用于代理内部网络对 Internet 的连接请求，客户机必须指定代理服务器,并将本来要直接发送到 Web 服务器上的 Http 请求发送到代理服务器中。  \n\n> **反向代理**服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器与目标主机一起对外表现为一个服务器。    \n\n![image](https://note.youdao.com/yws/api/personal/file/13C7AE322B474D6C9F2C0EDBCF791A60?method=download&shareKey=ae96160af45f2e89cf8925ce3e4a3d5f)  \n\n#### 负载均衡  \n> 负载均衡，英文名称为 Load Balance，其意思就是**分摊到多个操作单元上进行执行**，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务  \nNginx提供的负载均衡策略有2种：**内置策略和扩展策略**。内置策略为轮询，加权轮询，Ip hash。\n\n### DEMO  \n\n#### 安装、运行 Nginx \n\n```\n# 新建 docker-compose.yml 文件 \nversion: '3.1'\nservices:\n  nginx:\n    restart: always\n    image: nginx\n    container_name: nginx\n    ports:\n      - 80:8080\n      - 81:8081\n    volumes:\n      - ./conf/nginx.conf:/etc/nginx/nginx.conf\n      - ./wwwroot:/usr/local/docker/nginx/wwwroot\n### end file\n\n# 新建 ./wwwroot 目录 和 ./conf/nginx.conf 文件\n```\n\n\n#### 代理 tomcat 服务器\n> 启动两个 tomcat ，用 Nginx 反向代理 tomcat \n\n```\n# 使用docker-compose.yml启动 tomcat\nversion: '3'\nservices:\n  tomcat1:\n    image: tomcat\n    container_name: tomcat1\n    ports:\n      - 8080:8080\n\n  tomcat2:\n    image: tomcat\n    container_name: tomcat2\n    ports:\n      - 8081:8080\n# 启动\ndocker-compose up -d\n\n# 修改 ./conf/nginx.conf 配置文件\nworker_processes  1;\nevents {\n    worker_connections  1024;\n}\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream tomcatServer1 {\n        server 192.168.213.128:8080;\n    }\n    upstream tomcatServer2 {\n        server 192.168.213.128:8081;\n    }\n    # 配置一个虚拟主机\n    server {\n        listen 8080;\n        server_name tomcat1;\n        location / {\n            proxy_pass http://tomcatServer1;\n            index index.jsp index.html index.htm;\n        }\n    }\n    server {\n        listen 8081;\n        server_name tomcat2;\n        location / {\n            proxy_pass http://tomcatServer2;\n            index index.jsp index.html index.htm;\n        }\n    }\n}\n\n# 启动 Nginx\ndocker-compose up\n\n# 测试，访问 http://NginxIp:80 \n```\n\n#### 如何配置负载均衡？  \n\n```\n# ./conf/nginx.conf 文件upstream下配置\n\n# 定义负载均衡设备的 Ip及设备状态 \nupstream myServer {\n    server 127.0.0.1:9090 down;\n    server 127.0.0.1:8080 weight=2;\n    server 127.0.0.1:6060;\n    server 127.0.0.1:7070 backup;\n}\n\n# upstream：每个设备的状态:\n# down：表示当前的 server 暂时不参与负载\n# weight：默认为 1 weight 越大，负载的权重就越大。\n# max_fails：允许请求失败的次数默认为 1 当超过最大次数时，返回 proxy_next_upstream 模块定义的错误\n# fail_timeout:max_fails 次失败后，暂停的时间。\n# backup：其它所有的非 backup 机器 down 或者忙的时候，请求 backup 机器。所以这台机器压力会最轻\n\n# 在需要使用负载的 Server 节点下添加\nproxy_pass http://myServer;\n```","tags":["Nginx","负载均衡","反向代理"]},{"title":"如何在一台电脑上配置多个Git的SSH key","url":"/2019/11/21/如何在一台电脑上配置多个Git的SSH key/","content":"\n### 需求  \n> 需要用到多个代码托管平台时，就需要在同一台电脑上配置多个SSH-Key\n\n### 开始配置\n> 下面步骤演示配置本地局域网的GitLab 和 Github  \n- **生成SSH-Key**\n\n```\n# 生成GitLab的ssh key\n$ ssh-keygen -t rsa -C \"youemail@email.com” -f ~/.ssh/gitlab_rsa\n\n# 生成GitHub的ssh key  \n$ ssh-keygen -t rsa -C \"youemail@email.com” -f ~/.ssh/github_rsa\n```\n\n- **复制 ~/.ssh 目录下的pub key到平台**  \n![image](https://note.youdao.com/yws/api/personal/file/6AA860059A7B433BA22CDEFF9DB79A76?method=download&shareKey=6061be696a3fb00cd43bae82619fb497)\n\n- **在 ~/.ssh 目录下添加 config 文件**  \n\n```\n# gitlab\nHost 192.168.213.133\nPort 2222\nHostName 192.168.213.133\nPreferredAuthentications publickey\nIdentityFile C:/Users/13485/.ssh/gitlab_rsa\nUser Tooi\n \n# github\nHost github.com\nHostName github.com\nPreferredAuthentications publickey\nIdentityFile C:/Users/13485/.ssh/github_rsa\nUser Tooi6\n```\n\n\n```\n\n# 配置文件参数\n# Host : Host可以看作是一个你要识别的模式，对识别的模式，进行配置对应的的主机名和ssh文件（可以直接填写ip地址）\n# HostName : 要登录主机的主机名（建议与Host一致）\n# User : 登录名（如gitlab的username）\n# IdentityFile : 指明上面User对应的identityFile路径\n# Port: 端口号（如果不是默认22号端口则需要指定）\n```\n\n\n- **测试**\n\n```\n$ ssh -T git@github.com\n```\n","tags":["Git"]},{"title":"【树莓派】安装OpenCV","url":"/2019/11/18/【树莓派】安装OpenCV/","content":"\n### 配置摄像头  \n- **开启树莓派摄像头设置**\n> 查看博客[【树莓派】系统安装和配置 ](https://tooi6.github.io/2019/11/15/%E3%80%90%E6%A0%91%E8%8E%93%E6%B4%BE%E3%80%91%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%20%20/ )\n \n- **设置设备**  \n\n```\n# 添加设备 \nsudo nano /etc/modules\n# 末尾添加  \nbcm2835-v4l2\n# 检测\nvcgencmd get_camera\n# 输出：supported=1 detected=0 连接成功  \n\n# 拍照\nraspistill -t 1000 -o image.jpg\n```\n  \n### 开始安装OpenCV\n\n- **准备**  \n```\n# 安装numpy\nsudo pip3 install numpy\n\n# 在树莓派设置中把根目录扩大到整个SD卡\nsudo raspi-config\n# 选择 Advanced Options  \n# Expand Filesystem \n# 重启 reboot  \n\n# 安装所需的库\nsudo apt-get install build-essential git cmake pkg-config -y\nsudo apt-get install libjpeg8-dev -y\nsudo apt-get install libtiff5-dev -y\nsudo apt-get install libjasper-dev -y\nsudo apt-get install libpng12-dev -y\n\nsudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev -y\n\nsudo apt-get install libgtk2.0-dev -y\nsudo apt-get install libatlas-base-dev gfortran -y\n\n# 下载OpenCV  \ncd /home/pi/Download  \nwget https://github.com/Itseez/opencv/archive/3.4.0.zip\nwget https://github.com/Itseez/opencv_contrib/archive/3.4.0.zip\n# 百度云\n# 链接：https://pan.baidu.com/s/1AiiO9bVpkrUl7qUift2H5Q \n# 提取码：san9 \n\n# 解压\nunzip opencv-3.4.0.zip\nunzip opencv_contrib-3.4.0.zip\n\n# 编译\ncd /home/pi/Downloads/opencv-3.4.0\nmkdir build\ncd build\ncmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/home/pi/Downloads/opencv_contrib-3.4.0/modules -D BUILD_EXAMPLES=ON -D WITH_LIBV4L=ON PYTHON3_EXECUTABLE=/usr/bin/python3.5 PYTHON_INCLUDE_DIR=/usr/include/python3.5 PYTHON_LIBRARY=/usr/lib/arm-linux-gnueabihf/libpython3.5m.so PYTHON3_NUMPY_INCLUDE_DIRS=/home/pi/.local/lib/python3.5/site-packages/numpy/core/include ..\n# 等待15分钟\n```\n根据下图判断是否编译成功    \n\n![image](https://note.youdao.com/yws/api/personal/file/25A5D389ADF749B8B7DA21F79283CFDB?method=download&shareKey=aef794f28d36fa21b07cc6af743ec8c1)\n\n- **开始编译**  \n\n```\n# 编译\ncd /home/pi/Downloads/opencv-3.4.0/build\nmake\n# 等5个小时。。。\n\n# 成功后安装  \nsudo make insall\n```\n\n- **测试**\n\n```\npython\n###\n>>> import cv2\n>>> cv2.__version__\n'3.4.0'\n###\n```\n\n\n","tags":["OpenCV"]},{"title":"Redis 的搭建","url":"/2019/11/16/Redis Sentinel 集群部署/","content":"\n### 简介\n\n#### 什么是Redis？  \n> Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、**可基于内存亦可持久化**的日志型、**Key-Value数据库**，并提供多种语言的API  \n\n#### Redis 的应用场景\n> **缓存：** 做数据库缓存，可以提升服务器性能  \n**排行榜：** redis的SortSet数据结构自动排序，适合用来做排行榜  \n**计算器/限速器：** redis中原子性的自增操作，可以用来做统计用户访问数，点赞数等，限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力  \n**好友关系**，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能  \n**简单的消息队列：** 除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦  \n**Session共享**，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。  \n\n### Redis Sentinel 集群部署  \n\n#### 搭建 Redis 集群\n\n```\nversion: '3.1'\nservices:\n  master:\n    image: redis\n    container_name: redis-master\n    ports:\n      - 6379:6379\n\n  slave1:\n    image: redis\n    container_name: redis-slave-1\n    ports:\n      - 6380:6379\n    command: redis-server --slaveof redis-master 6379\n\n  slave2:\n    image: redis\n    container_name: redis-slave-2\n    ports:\n      - 6381:6379\n    command: redis-server --slaveof redis-master 6379\n```\n\n#### 搭建 Sentinel 集群  \n\n```\n# 新建 docker-compose.yml\nversion: '3.1'\nservices:\n  sentinel1:\n    image: redis\n    container_name: redis-sentinel-1\n    ports:\n      - 26379:26379\n    command: redis-sentinel /usr/local/etc/redis/sentinel.conf\n    volumes:\n      - ./sentinel1.conf:/usr/local/etc/redis/sentinel.conf\n\n  sentinel2:\n    image: redis\n    container_name: redis-sentinel-2\n    ports:\n      - 26380:26379\n    command: redis-sentinel /usr/local/etc/redis/sentinel.conf\n    volumes:\n      - ./sentinel2.conf:/usr/local/etc/redis/sentinel.conf\n\n  sentinel3:\n    image: redis\n    container_name: redis-sentinel-3\n    ports:\n      - 26381:26379\n    command: redis-sentinel /usr/local/etc/redis/sentinel.conf\n    volumes:\n      - ./sentinel3.conf:/usr/local/etc/redis/sentinel.conf\n\n# 新建 sentinel.conf 三份配置文件\nport 26379\ndir /tmp\nsentinel monitor mymaster 127.0.0.1 6379 2  # sentinel 自定义名 redis master的ip 端口 投票数\nsentinel down-after-milliseconds mymaster 30000\nsentinel parallel-syncs mymaster 1\nsentinel failover-timeout mymaster 180000\nsentinel deny-scripts-reconfig yes\n```","tags":["Redis"]},{"title":"使用 GitLab Runner 实现持续集成","url":"/2019/11/16/使用 GitLab Runner 实现持续集成/","content":"\n### 概述  \n#### 什么是持续集成、交付、部署？  \n- **持续集成：**  \n> 持续集成强调开发人员提交了新代码之后，**立刻进行构建、（单元）测试**。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。\n- **持续交付：**\n> 持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的 **类生产环境（production-like environments）** 中。如果代码没有问题，可以继续手动部署到生产环境中。\n- **持续部署：**\n> 持续部署则是在持续交付的基础上，把**部署到生产环境的过程自动化**    \n![image](https://note.youdao.com/yws/api/personal/file/31BFA0F6FF4D4BB3A5CC30B1F301E8FB?method=download&shareKey=3662d215358c3e875a367f453f5ab3ef)\n\n#### 持续集成的流程\n- **提交**\n> 开发者想代码仓库提交代码\n- **测试（第一轮）：**\n> 代码仓库对 commit 操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试\n- **构建**\n> 通过第一轮测试，代码就可以合并进主干，就算可以交付了。交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是**将源码转换为可以运行的实际代码**，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等\n- **测试（第二轮）**  \n> 第二轮是**全面测试**，单元测试和集成测试都会跑，有条件的话，也要做端对端测试。所有测试以自动化为主，少数无法自动化的测试用例，就要人工跑。  \n- **部署**\n> 通过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。\n- **回滚**\n> 一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指向上一个版本的目录。\n\n### 使用GitLab持续集成  \n\n#### Docker 部署GitLab Runner\n\n- **环境准备**\n\n```\n# 创建目录\nmkdir /usr/local/docker/runner\nmkdir /usr/local/docker/runner/environment\n\n# 下载jdk到 environment 目录下\n# 在 environment 下新建 daemon.json 配置加速器和仓库地址  \n{\n  \"registry-mirrors\": [\n    \"https://kzzvxj0z.mirror.aliyuncs.com\"\n  ],\n  \"insecure-registries\": [\n    \"192.168.213.132:5000\"\n  ]\n}\n```\n\n- **Dockerfile**\n\n```\n# 在 environment 目录下新建 Dockfile\n\nFROM gitlab/gitlab-runner:v11.0.2\nMAINTAINER Lusifer <topsale@vip.qq.com>\n\n# 修改软件源\nRUN echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse' > /etc/apt/sources.list && \\\n    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse' >> /etc/apt/sources.list && \\\n    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse' >> /etc/apt/sources.list && \\\n    echo 'deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse' >> /etc/apt/sources.list && \\\n    apt-get update -y && \\\n    apt-get clean\n\n# 安装 Docker\nRUN apt-get -y install apt-transport-https ca-certificates curl software-properties-common && \\\n    curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - && \\\n    add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" && \\\n    apt-get update -y && \\\n    apt-get install -y docker-ce\nCOPY daemon.json /etc/docker/daemon.json\n\n# 安装 Docker Compose\nWORKDIR /usr/local/bin\nRUN wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose\nRUN chmod +x docker-compose\n\n# 安装 Java\nRUN mkdir -p /usr/local/java\nWORKDIR /usr/local/java\nCOPY jdk-8u152-linux-x64.tar.gz /usr/local/java\nRUN tar -zxvf jdk-8u152-linux-x64.tar.gz && \\\n    rm -fr jdk-8u152-linux-x64.tar.gz\n\n# 安装 Maven\nRUN mkdir -p /usr/local/maven\nWORKDIR /usr/local/maven\nRUN wget https://raw.githubusercontent.com/topsale/resources/master/maven/apache-maven-3.5.3-bin.tar.gz\n# COPY apache-maven-3.5.3-bin.tar.gz /usr/local/maven\nRUN tar -zxvf apache-maven-3.5.3-bin.tar.gz && \\\n    rm -fr apache-maven-3.5.3-bin.tar.gz\n# COPY settings.xml /usr/local/maven/apache-maven-3.5.3/conf/settings.xml\n\n# 配置环境变量\nENV JAVA_HOME /usr/local/java/jdk1.8.0_152\nENV MAVEN_HOME /usr/local/maven/apache-maven-3.5.3\nENV PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin\n\nWORKDIR /\n```\n\n- **开始构建**  \n\n```\n# 在 runner 目录下新建docker-compose.yml  \nversion: '3.1'\nservices:\n  gitlab-runner:\n    build: environment\n    restart: always\n    container_name: gitlab-runner\n    privileged: true\n    volumes:\n      - /usr/local/docker/runner/config:/etc/gitlab-runner\n      - /var/run/docker.sock:/var/run/docker.sock\n\n# 开始构建\ndocker-compose up -d\n```\n\n- **注册Runner**\n> 先在 项目>设置>CI/CD>Runner 下查看：  \n![image](https://note.youdao.com/yws/api/personal/file/050A604056834955BFB6CBBDEC3DD364?method=download&shareKey=9b94fca8ff0a6b19bf4b873c38ed0bcb)\n\n```\n# 注册Runner\ndocker exec -it gitlab-runner gitlab-runner register\n\n# 输入 GitLab 地址\nPlease enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):\nhttp://192.168.213.133:8080/\n\n# 输入 GitLab Token\nPlease enter the gitlab-ci token for this runner:\nui6B3hj28Biv99ssyTJz\n\n# 输入 Runner 的说明\nPlease enter the gitlab-ci description for this runner:\n可以为空\n\n# 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci\nPlease enter the gitlab-ci tags for this runner (comma separated):\ndeploy\n\n\n# 选择 runner 执行器，这里我们选择的是 shell\nPlease enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:\nshell\n```\n\n#### 配置项目   \n> 以 iCoin-eureka 为例子：\n\n- **新建 .gitlab-ci.yml 文件**\n\n```\nstages:\n  - build\n  - push\n  - run\n  - clean\n\nbuild:\n  stage: build\n  script:\n    - /usr/local/maven/apache-maven-3.5.3/bin/mvn clean package   # mvn 打包\n    - cp target/icoin-eureka-1.0.0-SNAPSHOT.jar docker            # 取出jar包\n    - cd docker                                                   \n    - docker build -t 192.168.213.132:5000/icoin-eureka .         # 构建镜像\n\npush:\n  stage: push\n  script:\n    - docker push 192.168.213.132:5000/icoin-eureka               # push 到register\n\nrun:\n  stage: run\n  script:\n    - cd docker\n    - docker-compose down                                        # 先关闭之前的\n    - docker-compose up -d                                       # 启动\nclean:\n  stage: clean\n  script:\n    - docker rmi $(docker images -q -f dangling=true)            # 清理\n\n```\n\n- **新建Dockerfile**  \n> 使用 dockerize 等待 icoin-config 启动再运行\n```\nFROM openjdk:8-jre\nMAINTAINER Tooi <1348562497@qq.com>\n\nENV APP_VERSION 1.0.0-SNAPSHOT\n\nENV DOCKERIZE_VERSION v0.6.1\nRUN wget https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\\n    && tar -C /usr/local/bin -xzvf dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz \\\n    && rm dockerize-linux-amd64-$DOCKERIZE_VERSION.tar.gz\n#COPY dockerize-alpine-linux-amd64-v0.6.1.tar.gz /\n#\n#RUN tar -C /usr/local/bin -xzvf dockerize-alpine-linux-amd64-v0.6.1.tar.gz \\\n#\t&& rm dockerize-alpine-linux-amd64-v0.6.1.tar.gz\n\nRUN mkdir /app\n\nCOPY icoin-eureka-$APP_VERSION.jar /app/app.jar\n\nENTRYPOINT [\"dockerize\", \"-timeout\", \"5m\", \"-wait\", \"http://192.168.213.129:8888/icoin-eureka/prod\", \"java\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"/app/app.jar\", \"--spring.profiles.active=prod\"]\n\nEXPOSE 8888\n```\n\n- **新建 docker-conpose.yml**\n\n```\nversion: '3.1'\nservices:\n  icoin-eureka:\n    restart: always\n    image: 192.168.213.132:5000/icoin-eureka\n    container_name: icoin-eureka\n    ports:\n      - 8761:8761\n    networks:\n      - eureka_network\n\nnetworks:\n  eureka_network:\n```\n\n","tags":["持续集成","GitLab Runner"]},{"title":"【树莓派】系统安装和配置","url":"/2019/11/15/【树莓派】系统安装和配置/","content":"\n### 官网\n> https://www.raspberrypi.org/\n\n#### 中文社区\n> 树莓派实验室：http://shumeipai.nxez.com/  \nLinux 中国：https://linux.cn/tech/raspberrypi/\n\n### 安装系统\n> raspbian 历史版本：http://downloads.raspberrypi.org/raspbian/images/    \n\n#### 下载系统\n\n#### 写入镜像\n> 使用 Etcher 等工具写入系统镜像\n\n#### 设置wifi和ssh\n\n```\n# 在boot文件夹下新建 ssh 和 wpa_supplicant.conf 文件  \n\n# wpa_supplicant.conf 文件：\ncountry=GB\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\nnetwork={\n        ssid=\"Tooi\"\n        psk=\"zx123456\"\n        priority=1\n}\n## ssid：wifi名称\n## psk：wifi密码\n## prioity：优先级（越小优先级越高）\n```\n\n#### 使用 ssh 连接树莓派\n> 账号：pi   \n默认密码：raspberry\n\n#### 更换源\n> 查看有哪些源：https://www.raspbian.org/RaspbianMirrors\n\n\n```\n# 编辑\nsudo nano /etc/apt/sources.list\n# 将内容替换成：\ndeb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi\ndeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi\n\n# 更新\nsudo apt-get update\n```\n> 如果使用 wifi 网速慢的话可以试试更换DNS：  \nsudo nano /etc/resolv.conf   \nnameserver 8.8.8.8  \n\n#### 更换 pip 源  \n\n```\nsudo mkdir ~/.pip\nsudo nano ~/.pip.conf\n\n[global]\ntimeout = 10\nindex-url =  http://mirrors.aliyun.com/pypi/simple/\nextra-index-url= http://pypi.douban.com/simple/\n[install]\ntrusted-host=\n    mirrors.aliyun.com\n    pypi.douban.com\n```\n\n#### 配置树莓派\n> sudo raspi-config  \n\n![image](https://note.youdao.com/yws/api/personal/file/995813D581F44829A17F483742A7652A?method=download&shareKey=be956a1a46d86d3860497cb11f5c16d0)\n\n- **Change User Password：**  \n> 修改当前用户的密码\n\n- **Localisation Options** ：\n> 本地化设置（修改地区，时区，wifi）  \n- **Interfacing Options**\n> 打开Camera（相机）、SSH、Serial、Remote GPIO\n- **Advanced Options**\n> 选择**Expand Filesystem**，将根目录扩展到这个SD卡，充分利用SD卡的存储空间  \n选择**Overscan**，在整个屏幕上显示    \n选择**Audio**，选择Force 3.5mm('headphone' jack)，树莓派的声音会从耳机孔输出  \n选择**Resolution**，选择默认设置，自动根据显示屏调整分辨率  \n选择**Pixel Doubling**，增加桌面显示画质  \n\n#### 使用 VNC 连接  \n\n```\n# 进入 Interfacing Options 配置，开启 VNC\nsudo raspi-config  \n\n# 新建配置文件\nsudo nano /etc/init.d/vncserver\n### begin ###\n#!/bin/sh\n### BEGIN INIT INFO\n# Provides: vncserver\n# Required-Start: $local_fs\n# Required-Stop: $local_fs\n# Default-Start: 2 3 4 5\n# Default-Stop: 0 1 6\n# Short-Description: Start/stop vncserver\n### END INIT INFO\n# More details see:\n# http://www.penguintutor.com/linux/vnc\n### Customize this entry\n# Set the USER variable to the name of the user to start vncserver under\nexport USER='pi'\n### End customization required\neval cd ~$USER\ncase \"$1\" in\nstart)\n# 启动命令行。此处自定义分辨率、控制台号码或其它参数。\nsu $USER -c '/usr/bin/vncserver -depth 16 -geometry 1024x768 :1'\necho \"Starting VNC server for $USER \"\n;;\nstop)\n# 终止命令行。此处控制台号码与启动一致。\nsu $USER -c '/usr/bin/vncserver -kill :1'\necho \"vncserver stopped\"\n;;\n*)\necho \"Usage: /etc/init.d/vncserver {start|stop}\"\nexit 1\n;;\nesac\nexit 0\n### end ###\n\n# 修改权限\nsudo chmod 755 /etc/init.d/vncserver  \n\n# 开机启动  \nsudo update-rc.d vncserver defaults\n\n# 重启 \nsudo reboot\n\n# 开机后就可以连接了\n账户：pi\n默认密码：raspberry\n```\n\n","tags":["树莓派"]},{"title":"Python web 之 Django 入门","url":"/2019/11/14/Python web 之 Django 入门/","content":"\n### Python 虚拟环境  \n\n#### 为什么使用虚拟环境？  \n> 在使用Python语言的时候我们使用pip来安装第三方包，但是由于pip的特性，系统中只能安装每个包的一个版本。但是在实际项目开发中，不同项目可能需要第三方包的不同版本，Python的解决方案就是虚拟环境。顾名思义，虚拟环境就是虚拟出来的一个隔离的Python环境，每个项目都可以有自己的虚拟环境，用pip安装各自的第三方包，不同项目之间也不会存在冲突。\n\n#### 使用\n\n```\n# 安装 virtualenvwrapper-win  \npip3 install virtualenvwrapper-win  \n\n# 新建虚拟环境 py3scrapy \nmkvirtualenv py3scrapy\n\n# 进入虚拟环境  \nworkon py3entest\n\n# 退出\ndeactivate\n\n# 虚拟环境默认放在 C:\\%User%\\13485\\Envs 目录下 \n```\n\n### 概述\n#### 什么是 Django？   \n> Django是一个开放源代码的Web应用框架，由Python写成。采用了**MTV**的框架模式，即**模型M，视图V和模版T**。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。\n\n#### MTV 与 MVC 的区别？\n- **MVC**\n    - Model：数据存取层，负责业务对象和数据库的对象(ORM)的映射\n    - View：视图层，负责与用户的交互(书写逻辑)\n    - Controller：完成用户对模型层和视图层调用,来完成用户的请求\n- **MTV**\n    - Model：数据存取层，负责业务对象与数据库的对象(ORM)的映射\n    - Template：负责如何把页面展示给用户(html)\n    - View：负责业务逻辑，并在适当的时候调用Model和Template\n- **区别：**\n> MVC中的View的目的是**呈现哪一个数据**，而MTV的View的目的是**数据如何呈现** 。  \n也就说MTV把View分成了**视图（展现哪些数据）** 和 **模板（如何展现）** 2个部分，而Contorller这个要素由框架自己来实现了\n\n\n### Demo  \n> 参考：https://blog.csdn.net/niedongri/article/details/81978284\n\n### 详细教程\n> W3School：https://www.w3cschool.cn/django/django-tutorial.html\n","tags":["Python","Django"]},{"title":"Spring Boot & Spring Boot Netflix","url":"/2019/11/10/Spring Boot & Spring Boot Netflix/","content":"\n### 概述  \n\n### Demo\n> 具体项目放在GitHub仓库：https://github.com/Tooi6/demo-spring-cloud\n\n#### 统一依赖管理（demo-dependencies）\n> 所有项目都会依赖这个项目，配置一些项目需要用到的插件、下载依赖时的第三方库  \n\n#### demo-eureka（服务注册与发现）\n>  Spring Cloud Netflix 的 Eureka，Eureka 是一个服务注册和发现模块  \n\n```\n<dependencies>\n    <!-- Spring Boot Begin -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <!-- Spring Boot End -->\n\n    <!-- Spring Cloud Begin -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n    <!-- Spring Cloud End -->\n</dependencies>\n\n# application.yml \nspring:\n  application:\n    name: demo-tooi-eureka\n\nserver:\n  port: 8761\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n\n#### 服务提供者（demo-service-admin）\n> Eureka Client 注册到Eureka Service，提供服务  \n\n```\n<dependencies>\n    <!-- Spring Boot Begin -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <!-- Spring Boot End -->\n\n    <!-- Spring Cloud Begin -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n    <!-- Spring Cloud End -->\n</dependencies>\n\n# application.yml\nspring:\n  application:\n    name: demo-service-admin\n\nserver:\n  port: 8763\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n```\n\n#### 服务消费者Ribbon（demo-web-admin-ribbon）\n> 在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于 http restful 的。Spring cloud 有两种服务调用方式，一种是 ribbon + restTemplate，另一种是 feign\n\n```\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n    </dependency>\n</dependencies>\n\n# 调用服务\n@Service\npublic class AdminService {\n    @Autowired\n    RestTemplate restTemplate;\n\n    public String sayHi(String message) {\n        return restTemplate.getForObject(\"http://DEMO-SERVICE-ADMIN/hi?message=\" + message, String.class);\n    }\n}\n```\n\n#### 服务消费者（Feign）  \n> Feign 默认集成了 Ribbon，并和 Eureka 结合，默认实现了负载均衡的效果  \n\n```\n# pom.xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n\n# 调用服务  \n@FeignClient(value = \"DEMO-SERVICE-ADMIN\")\npublic interface AdminService {\n    @GetMapping(\"hi\")\n    String sayHi(@RequestParam(\"message\") String message);\n}\n```\n\n#### 熔断器（Hystrix）\n> 当对特定的服务的调用的不可用达到一个阀值（Hystrix 是 5 秒 20 次） 熔断器将会被打开。熔断器打开后，为了避免连锁故障，通过 **fallback** 方法可以直接返回一个固定值。  \n\n- **Ribbon中使用**\n\n```\n# 添加依赖  \n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n\n# 在 Application 中增加 @EnableHystrix 注解  \n\n# 增加 fallbackMethod 熔断方法\n@HystrixCommand(fallbackMethod = \"hiError\")\npublic String sayHi(String message) {\n    return restTemplate.getForObject(\"http://DEMO-SERVICE-ADMIN/hi?message=\" + message, String.class);\n}\n\npublic String hiError(String message) {\n    return String.format(\"message：%s , request error.\",message);\n}\n```\n\n- **Feign中使用**  \n\n```\n# 添加依赖\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n\n# 配置 application.yml\nfeign:\n  hystrix:\n    enabled: true\n\n# 在 service 中指定 fallback 类\n@FeignClient(value = \"DEMO-SERVICE-ADMIN\",fallback = AdminServiceHystrix.class)\npublic interface AdminService {\n    @GetMapping(\"hi\")\n    String sayHi(@RequestParam(\"message\") String message);\n}\n\n# 创建并实现对应的Feign接口  \n@Component\npublic class AdminServiceHystrix implements AdminService {\n    @Override\n    public String sayHi(String message) {\n        return String.format(\"message：%s，request error\",message);\n    }\n}\n```\n\n#### Hystrix 仪表盘 （Dashboard）\n> \n\n- **Ribbon 和 Feign 改造方式相同** \n\n```\n# 添加依赖  \n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n\n# 在 Application 中添加 @EnableHystrixDashboard 注解\n\n# 添加类  \n@Configuration\npublic class HystrixDashboardConfiguration {\n    @Bean\n    public ServletRegistrationBean getServlet() {\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);\n        registrationBean.setLoadOnStartup(1);\n        registrationBean.addUrlMappings(\"/hystrix.stream\");\n        registrationBean.setName(\"HystrixMetricsStreamServlet\");\n        return registrationBean;\n    }\n}\n```\n\n#### 路由网关（demo-zuul）  \n> Zuul 的主要功能是**路由转发和过滤器**。路由功能是微服务的一部分。Zuul 默认和 Ribbon 结合实现了**负载均衡**的功能\n\n\n```\n# pom.xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n</dependency>\n\n# 在application 开启 @EnableZuulProxy 注解  \n\n# application.yml  \nspring:\n  application:\n    name: demo-zuul\n\nserver:\n  port: 8769\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n\nzuul:\n  routes:\n    api-a:\n      path: /api/a/**\n      serviceId: demo-web-admin-ribbon\n    api-b:\n      path: /api/b/**\n      serviceId: demo-web-admin-feign\n```\n\n- **配置网关路由失败时的回调**\n\n```\n# 添加类\n@Component\npublic class WebAdminFeignFallbackProvider implements FallbackProvider {\n\n    @Override\n    public String getRoute() {\n        // // ServiceId，如果需要所有调用都支持回退，则 return \"*\" 或 return null\n        return \"demo-web-admin-feign\";\n    }\n\n    /**\n     * 如果请求失败，则返回指定信息给调用者\n     *\n     * @param route\n     * @param cause\n     * @return\n     */\n    @Override\n    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {\n        return new ClientHttpResponse() {\n            /**\n             * 网关向 api 服务请求失败了，但是消费者客户端向网关发起的请求是成功的，\n             * 不应该把 api 的 404,500 等问题抛给客户端\n             * 网关和 api 服务集群对于客户端来说是黑盒\n             * @return\n             * @throws IOException\n             */\n            @Override\n            public HttpStatus getStatusCode() throws IOException {\n                return HttpStatus.OK;\n            }\n\n            @Override\n            public int getRawStatusCode() throws IOException {\n                return HttpStatus.OK.value();\n            }\n\n            @Override\n            public String getStatusText() throws IOException {\n                return HttpStatus.OK.getReasonPhrase();\n            }\n\n            @Override\n            public void close() {\n\n            }\n\n            @Override\n            public InputStream getBody() throws IOException {\n                ObjectMapper objectMapper = new ObjectMapper();\n                Map<String, Object> map = new HashMap<>();\n                map.put(\"status\", 200);\n                map.put(\"message\", \"无法连接，请检查您的网络\");\n                return new ByteArrayInputStream(objectMapper.writeValueAsString(map).getBytes(\"UTF-8\"));\n            }\n\n            @Override\n            public HttpHeaders getHeaders() {\n                HttpHeaders headers = new HttpHeaders();\n                // 和 getBody 中的内容编码一致\n                headers.setContentType(MediaType.APPLICATION_JSON_UTF8);\n                return headers;\n            }\n        };\n    }\n}\n```\n\n- **使用路由网关的服务过滤功能**  \n\n```\n# 添加过滤器类  \npublic class Filter extends ZuulFilter{\n    // 详细看源代码...\n}\n```\n\n#### 分布式配置中心\n> 在分布式系统中，由于服务数量巨多，为了方便服务配置**文件统一管理，实时更新**，所以需要分布式配置中心组件。  \n在 Spring Cloud Config 组件中，分两个角色，一是 Config Server，二是 Config Client。 \n\n> 新建git仓库：https://github.com/Tooi6/demo-remote-config.git\n\n\n- **服务端（demo-config）**\n\n```\n# pom.xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-config-server</artifactId>\n</dependency>\n\n# application.yml\nspring:\n  application:\n    name: demo-config\n  cloud:\n    config:\n      label: master\n      server:\n        git:\n          uri: https://github.com/Tooi6/demo-remote-config.git\n          search-paths: respo\n          username: youemail@emai.com\n          password: youpassword\nserver:\n  port: 8888\n  \neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n# 在 application 开启配置 @EnableConfigServer\n```\n\n- **客户端（改造Feign项目）**\n\n```\n# pom.xml 添加依赖\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n\n# application.yml\nspring:\n  cloud:\n    config:\n      uri: http://localhost:8888\n      name: web-admin-feign\n      label: master\n      profile: dev\n```\n\n#### 服务链路追踪 （zipkin）\n> ZipKin 是一个开放源代码的**分布式跟踪系统**，由 Twitter 公司开源，它致力于收集服务的定时数据，**以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。**\n\n```\n# pom.xml 添加依赖\n<dependency>\n    <groupId>io.zipkin.java</groupId>\n    <artifactId>zipkin</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.zipkin.java</groupId>\n    <artifactId>zipkin-server</artifactId>\n</dependency>\n<dependency>\n    <groupId>io.zipkin.java</groupId>\n    <artifactId>zipkin-autoconfigure-ui</artifactId>\n</dependency>\n\n# 在 application 启动注解 @EnableZipkinServer\n\n# application.yml\nspring:\n  application:\n    name: demo-zipkin\n\nserver:\n  port: 9411\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n\nmanagement:\n  metrics:\n    web:\n      server:\n        auto-time-requests: false\n\n# 给所有其他需要追踪的服务添加依赖\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zipkin</artifactId>\n</dependency>\n```\n\n#### Spring Boot Admin\n> Spring Boot Admin是一个开源社区项目，用于**管理和监控**SpringBoot应用程序。 \n\n- **Spring Boot Admin 服务端（demo-admin）**\n\n```\n# pom.xml\n<dependency>\n    <groupId>org.jolokia</groupId>\n    <artifactId>jolokia-core</artifactId>\n</dependency>\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-server</artifactId>\n</dependency>\n\n# 在 application 类中添加 @EnableAdminServer 注解  \n\n# application.yml\nspring:\n  application:\n    name: hello-spring-cloud-admin\n  zipkin:\n    base-url: http://localhost:9411\n\nserver:\n  port: 8084\n\nmanagement:\n  endpoint:\n    health:\n      show-details: always\n  endpoints:\n    web:\n      exposure:\n        include: health,info\n\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\n```\n\n- **客户端（改造其他项目）** \n\n```\n# pom.xml 添加依赖\n<dependency>\n    <groupId>org.jolokia</groupId>\n    <artifactId>jolokia-core</artifactId>\n</dependency>\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-client</artifactId>\n</dependency>\n\n# application.yml 添加配置  \nspring:\n  boot:\n    admin:\n      client:\n        url: http://localhost:8084\n```\n\n","tags":["微服务","Spring Cloud","Spring Boot","Spring Netflix"]},{"title":"微服务架构 & Spring Cloud","url":"/2019/11/10/微服务架构 & Spring Cloud/","content":"\n### 概述  \n#### 什么是微服务？\n> 微服务的概念源于2014年3月Martin Fowler所写的一篇文章“Microservices”。  \n**微服务架构：** 是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用**轻量级的通信机制**互相沟通（通常是基于HTTP的RESTful API）。  \n**微服务：** 是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是**松耦合**的。\n\n#### 微服务架构的优势\n- **复杂度可控：**  \n> 每一个微服务专注于**单一功能**，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。  \n- **独立部署：**  \n> 由于微服务具备**独立的运行进程**，所以每个微服务也可以独立部署。  \n- **技术选型灵活：**  \n> 微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。\n- **容错：**  \n> 在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过**重试、平稳退化**等机制实现应用层面的容错。\n- **扩展**  \n> 微服务架构在扩展功能方面具有灵活性，因为每个服务可以**根据实际需求独立进行扩展**\n\n#### 什么是SpringCloud？\n> SpringCloud是**微服务架构的集大成者**，将一系列优秀的组件进行了整合。SpringCloud的组件相当繁杂，拥有诸多子项目。重点关注**Netflix**\n\n\n### Spring Cloud的核心组件    \n![image](https://note.youdao.com/yws/api/personal/file/D47A17F9F0054D368770574184DB81FB?method=download&shareKey=56a5caadbcea630f69ae65cc14c960cd)  ","tags":["Spring Cloud","微服务架构"]},{"title":"使用 Docker Registry 搭建 Docker 私服","url":"/2019/11/06/使用 Docker Registry 搭建 Docker 私服/","content":"\n### 概述  \n> Docker官方提供了Docker Hub来维护管理所有的镜像,只是对于免费用户而言,只能创建一个私有仓库,付费用户才拥有更多私有仓库的权限,对此**官方开源**了Docker Registry的源代码,我们可以通过它在局域网内部搭建私有的镜像注册中心.\n\n### 部署和使用 Docker Registry  \n#### 部署环境  \n| 操作系统  | Ubuntu Server 16\\.04 LTS |\n|-----|---------------|\n| cpu | 2核            |\n| 内存  | 2G          |\n\n#### 部署  \n> Docker 镜像：https://hub.docker.com/_/registry  \n\n```\n### docker-compose.yml  \nversion: '3.1'\nservices:\n  registry:\n    image: registry\n    restart: always\n    container_name: registry\n    ports:\n      - 5000:5000\n    volumes:\n      - /usr/local/docker/registry/data:/var/lib/registry\n###\n\n# 运行  \ndocker-compose up\n\n# 测试 访问: http://ip:5000/v2/\n```\n\n#### 客户端使用 Registry 私服  \n\n```\n### 修改 /etc/docker/daemon.json 文件（没有则添加），加速器可以换成阿里云\n{\n  \"registry-mirrors\": [\n    \"https://registry.docker-cn.com\"\n  ],\n  \"insecure-registries\": [\n    \"ip:5000\"\n  ]\n}\n###\n\n# 重启\nsystemctl daemon-reload\nsystemctl restart docker\n\n# 查看配置是否成功\ndocker info\n\n# 上传本地镜像到 Registry\n## 标记本地镜像库（ip:port/image_name:tag，该格式为标记版本号）\ndocker tag tomcat 192.168.213.128:5000/tomcat:8.5.34\n\n## 提交镜像到仓库\ndocker push 192.168.213.128:5000/tomcat:8.5.34\n\n# 查看全部镜像\ncurl -XGET http://192.168.213.128:5000/v2/_catalog\n\n# 查看指定镜像\ncurl -XGET http://192.168.213.128:5000/v2/nginx/tags/list\n\n# 从 Registry 拉去镜像  \ndocker pull 192.168.213.128:5000/nginx\n```\n\n### 部署 Docker Registry WebUI \n> 给 Registry 安装一个UI界面  \n镜像：https://hub.docker.com/r/konradkleine/docker-registry-frontend\n\n\n```\n### docker-compose.yml \nversion: '3.1'\nservices:\n  registry:\n    image: registry\n    restart: always\n    container_name: registry\n    ports:\n      - 5000:5000\n    volumes:\n      - /usr/local/docker/registry/data:/var/lib/registry\n  frontend:\n    image: konradkleine/docker-registry-frontend:v2\n    ports:\n      - 8080:80\n    volumes:\n      - ./certs/frontend.crt:/etc/apache2/server.crt:ro\n      - ./certs/frontend.key:/etc/apache2/server.key:ro\n    environment:\n      - ENV_DOCKER_REGISTRY_HOST=192.168.213.128\n      - ENV_DOCKER_REGISTRY_PORT=5000\n###\n\n# 启动\ndocker-compose up\n\n# 访问：http://192.168.213.128:8080/\n```\n","tags":["Docker","Docker Registry"]},{"title":"GitLab 的使用与搭建","url":"/2019/11/06/GitLab 的部署与使用/","content":"\n### 简介  \n> GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。简单的说就是一个私人的GitHub。  \n\n官方文档：https://docs.gitlab.com/ee/README.html\n\n### 开始部署  \n#### 部署环境  \n| 操作系统  | Ubuntu Server 16\\.04 LTS |\n|-----|---------------|\n| cpu | 2核            |\n| 内存  | 2G          |\n\n#### 基于Docker部署  \n> Docker镜像：https://hub.docker.com/r/twang2218/gitlab-ce-zh\n\n```\n# 拉取镜像  \ndocker pull twang2218/gitlab-ce-zh\n\n### docker-compose.yml\nversion: '3'\nservices:\n    web:\n      image: 'twang2218/gitlab-ce-zh'\n      restart: always\n      hostname: '192.168.213.128'\n      environment:\n        TZ: 'Asia/Shanghai'\n        GITLAB_OMNIBUS_CONFIG: |\n          external_url 'http://192.168.213.128:8080'\n          gitlab_rails['gitlab_shell_ssh_port'] = 2222\n          unicorn['port'] = 8888\n          nginx['listen_port'] = 8080\n      ports:\n        - '8080:8080'\n        - '8443:443'\n        - '2222:22'\n      volumes:\n        - /usr/local/docker/gitlab/config:/etc/gitlab\n        - /usr/local/docker/gitlab/data:/var/opt/gitlab\n        - /usr/local/docker/gitlab/logs:/var/log/gitlab\n###\n\n# 启动  \ndocker-compose up\n```\n","tags":["Docker","GitLab"]},{"title":"使用 Nexus 搭建 Maven 私服","url":"/2019/11/06/使用 Nexus 搭建 Maven 私服/","content":"\n### 简介  \n> Nexus 是一个强大的**仓库管理器**，极大地简化了内部仓库的维护和外部仓库的访问。    \n\n### 部署 Nexus  \n#### 部署环境  \n| 操作系统  | Ubuntu Server 16\\.04 LTS |\n|-----|---------------|\n| cpu | 2核            |\n| 内存  | G          |\n\n#### 开始部署\n> Docker 镜像：https://hub.docker.com/r/sonatype/nexus3  \n\n```\n# 拉取镜像  \ndocker pull sonatype/nexus3  \n\n### docker-compose.yml  \nversion: '3.1'\nservices:\n  nexus:\n    restart: always\n    image: sonatype/nexus3\n    container_name: nexus\n    ports:\n      - 8081:8081\n    volumes:\n      - /usr/local/docker/nexus/data:/nexus-data\n###\n```\n\n### 开始使用  \n> 服务启动后第一次登陆需要输入密码，初始密码在服务器文件 nexus/data/admin.password 中。  \n\n#### 配置认证信息\n```\n# 在maven配置文件中添加   \n<server>\n  <id>nexus-releases</id>\n  <username>admin</username>\n  <password>adminpassowrd</password>\n</server>\n\n<server>\n  <id>nexus-snapshots</id>\n  <username>admin</username>\n  <password>adminpassowrd</password>\n</server>\n```\n\n#### 配置自动化部署\n\n```\n# 项目的pom中添加\n<distributionManagement>  \n  <repository>  \n    <id>nexus-releases</id>  \n    <name>Nexus Release Repository</name>  \n    <url>http://192.168.213.128:8081/repository/maven-releases/</url>  \n  </repository>  \n  <snapshotRepository>  \n    <id>nexus-snapshots</id>  \n    <name>Nexus Snapshot Repository</name>  \n    <url>http://192.168.213.128:8081/repository/maven-snapshots/</url>  \n  </snapshotRepository>  \n</distributionManagement> \n```\n\n\n#### 上传第三方 JAR 包  \n\n```\n# 如第三方JAR包：kaptcha-2.3.0.jar\nmvn deploy:deploy-file \n  -DgroupId=com.google.code.kaptcha \n  -DartifactId=kaptcha\n  -Dversion=2.3.0 \n  -Dpackaging=jar \n  -Dfile=D:\\codes\\kaptcha-2.3.0.jar \n  -Durl=http://192.168.213.128:8081/repository/maven-releases/\n  -DrepositoryId=nexus-releases\n```\n\n#### 配置代理仓库  \n\n```\n<repositories>\n    <repository>\n        <id>nexus-releases</id>\n        <name>Nexus Repository</name>\n        <url>http://192.168.213.128:8081/repository/maven-public/</url>\n        <snapshots>\n            <enabled>true</enabled>\n        </snapshots>\n        <releases>\n            <enabled>true</enabled>\n        </releases>\n    </repository>\n</repositories>\n<pluginRepositories>\n    <pluginRepository>\n        <id>nexus-releases</id>\n        <name>Nexus Plugin Repository</name>\n        <url>http://192.168.213.128:8081/repository/maven-public/</url>\n        <snapshots>\n            <enabled>true</enabled>\n        </snapshots>\n        <releases>\n            <enabled>true</enabled>\n        </releases>\n    </pluginRepository>\n</pluginRepositories>\n```\n","tags":["Docker","Nexus","Maven"]},{"title":"Docker 容器技术 & Docker Compose","url":"/2019/11/03/Docker 容器技术 & Docker Compose/","content":"\n### 简介\n#### 什么是Docker？  \n> Docker 是一个开源的**应用容器引擎**，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现**虚拟化**。容器是完全使用**沙箱机制**，相互之间不会有任何接口。  \n\n#### 虚拟机和容器的区别？  \n> **虚拟机：** 传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有**自己的操作系统**，虚拟机一旦被开启，**预分配给它的资源将全部被占用**  \n\n> **容器：** 容器技术是和我们的宿主机**共享硬件资源及操作系统**，可以实现**资源的动态分配**。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以**分离的进程运行。**    \n\n#### 容器技术的优势  \n| 特性    | 容器        | 虚拟机    |\n|-------|-----------|--------|\n| 启动    | 秒级        | 分钟级    |\n| 硬盘使用  | 一般为MB     | 一般为GB  |\n| 性能    | 接近原生      | 弱于     |\n| 系统支持量 | 单机支持上千个容器 | 一般是几十个 |\n\n### Docker 的基本概念  \n- **镜像（Image）：** \n> Docker 镜像是一个**特殊的文件系统**，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。**镜像不包含任何动态数据，其内容在构建之后也不会被改变**\n- **容器（Container）：** \n> 容器的实质是**进程**，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个**隔离的环境**里，使用起来，就好像是在一个独立于宿主的系统下操作一样  \n\n**镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。**\n- **仓库（Repository）：**  \n\n> Docker 仓库是**集中存放镜像文件的场所**。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry (仓库注册服务器)就是这样的服务  \n 官方仓库：https://hub.docker.com/search?q=&type=image   \n \n- **Docker引擎**  \n> Docker 引擎是一个包含以下主要组件的客户端服务器应用程序（CS架构）。  \n**服务器(server)**，它是一种称为**守护进程**并且长时间(后台)运行的程序。  \n**REST API**，用于指定程序可以用来与守护进程通信的接口，并指示它做什么。  \n**客户端（Client）**，有命令行界面 (CLI) 工具  \n\n![image](https://note.youdao.com/yws/api/personal/file/851252360E394E6A8A63E181ED3E3203?method=download&shareKey=c1c71de21d8043aaa3d033697078fb02)\n\n### 如何使用？  \n#### 安装Docker \n\n```\n# 卸载旧版本  \nsudo apt-get autoremove docker docker-engine docker.io\n\n# 使用APT安装  \nsudo apt-get update \n## 安装必要的工具\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common  \n## 安装 GPG 证书\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -  \n## 写入软件源信息  \nsudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"  \n## 更新并安装 \nsudo apt-get -y update\nsudo apt-get -y install docker-ce\n\n# 使用脚本自动安装（推荐）  \ncurl -fsSL get.docker.com -o get-docker.sh\nsudo sh get-docker.sh --mirror Aliyun\n\n# 启动 Docker CE\nsudo systemctl enable docker\nsudo systemctl start docker\n\n# 添加docker用户组  \ngroupadd docker    # 一般脚本已经建好了\nusermod -aG docker $USER\n\n# 运行hello-world\ndocker run hello-world\n```\n\n#### 配置镜像加速  \n> 下面是docker官方提供的，使用阿里云的更快：https://cr.console.aliyun.com/#/accelerator\n\n```\nvim /etc/docker/daemon.json  # 没有则新建\n## 写入内容\n{\n  \"registry-mirrors\": [\n    \"https://registry.docker-cn.com\"\n  ]\n}\n\n# 重启docker\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n#### 基本操作  \n```\n# 下载镜像  \ndocker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] \n#下载tomcat镜像，默认下载官方的latest标签\ndocker pull tomcat   \n\n# 查看本地镜像  \ndocker images\n\n# 运行镜像  \ndocker run -d -p 8080:8080 tomcat  # -d:后台运行 -p:绑定端口 \n# 查看容器  \ndocker ps\n# 停止容器  \ndocker stop [NAME]\n# 其他命令\nhttps://www.runoob.com/docker/docker-command-manual.html\n```\n\n### 使用 Dockerfile 定制镜像\n#### demo：\n\n```\n# 创建Dockerfile\nFORM tomcat\nWORKDIR /usr/local/tomcat/webapps/ROOT/\nRUN \"hello Dockerfile\" > index.html\n\n# 构建镜像  \ndocker build -t mytomcat .\n\n# 运行  \ndocker run -p 80:8080 mytomcat bash  \n```\n\n#### 镜像构建上下文（Context）  \n> https://blog.csdn.net/small_to_large/article/details/77435541  \n\n#### Dockerfile 指令  \n> 官方文档：https://docs.docker.com/engine/reference/builder/\n\n### 使用数据卷构建MySQL  \n#### 什么是数据卷？  \n> 数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 **UFS**，可以提供很多有用的特性  \n- 数据卷 可以在**容器之间共享和重用**  \n- 对 数据卷 的**修改会立马生效**  \n- 对 数据卷 的**更新，不会影响镜像**  \n- 数据卷 默认会**一直存在**，即使容器被删除 **（MySQL可以用它来实现持久化）**\n\n#### 构建MySQL\n> 将本地文件加挂载到MySQL容器上，实现MySQL的持久化\n\n```\n# 拉取镜像  \ndocker pull mysql:5.7.28\n\n# 使用数据卷启动MySQL  \ndocker run -p 3306:3306 --name mysql \\\n-v /usr/local/docker/mysql/logs:/var/log/mysql \\\n-v /usr/local/docker/mysql/data:/var/lib/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-d mysql:5.7.28\n\n## 复制docker容器内容到宿主机  \ndocker cp mysql:/etc/mysql .  # 可以将MySQL配置负责到本地\n```\n\n### Docker Compose  \n#### 什么是 Docker Compose\n> Compose 项目是 Docker 官方的开源项目，负责实现**对 Docker 容器集群的快速编排。**    \nDocker Compose 它允许用户通过一个单独的 **docker-compose.yml** 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n#### 下载、安装  \n\n```\n# GitHub地址：https://github.com/docker/compose\n\n# 下载，并安装\ncurl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\n\n# 验证\ndocker-compose version\n\n# 卸载，直接删除二进制文件即可  \nrm /usr/local/bin/docker-compose\n```\n\n#### DEMO\n> \n\n```\n# 新建文件docker-compose.yml\n\n### 配置tomcat、MySQL\nversion: '3'\nservices:\n  tomcat:\n    restart: always\n    image: tomcat\n    container_name: tomcat\n    ports:\n      - 8080:8080\n    volumes:\n      - /usr/local/docker/tomcat/ROOT:/usr/local/tomcat/webapps/ROOT\n  mysql:\n    restart: always\n    image: mysql:5.7.22\n    container_name: mysql\n    ports:\n      - 3306:3306\n    environment:\n      TZ: Asia/Shanghai\n      MYSQL_ROOT_PASSWORD: 123456\n    command:\n      --character-set-server=utf8mb4\n      --collation-server=utf8mb4_general_ci\n      --explicit_defaults_for_timestamp=true\n      --lower_case_table_names=1\n      --max_allowed_packet=128M\n      --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\n    volumes:\n      - mysql-data:/var/lib/mysql\n\nvolumes:\n  mysql-data:\n###\n\n# 启动\ndocker-compose up -d\n```\n\n### Docker 常用命令  \n\n```\n# 查看 Docker 版本\ndocker version\n\n# 从 Dockerfile 文件构建镜像\ndocker build -t image-name .\n\n# 运行 Docker 镜像\ndocker run -d image-name\n\n# 查看Docker镜像\ndocker images\n\n# 查看运行的容器\ndocker ps\ndocker ps -al # 查看所有容器  \n\n# 停止容器  \ndocker stop conainer_id\n\n# 删除一个镜像  \ndocker rmi iamge-name\n\n# 删除所有镜像\ndocker rmi $(docker images -q)\n\n# 强制删除所有镜像\ndocker rmi -r $(docker images -a)\n\n# 删除所有虚悬镜像\ndocker rmi $(docker images -q -f dangling=true)\n\n# 删除所有容器\ndocker rm $(docker ps -a -q)\n\n# 进入 Docker 容器\ndocker exec -it container-id /bin/bash\n\n# 查看数据卷  \ndocker volume ls\n\n# 删除指定数据卷\ndocker volume rm [volume_name]\n\n# 删除所有未关联的数据卷\ndocker volume rm $(docker volume ls -qf dangling=true)\n\n# 从主机复制文件到容器\nsudo docker cp host_path containerID:container_path\n\n# 从容器复制文件到主机\nsudo docker cp containerID:container_path host_path\n```\n\n","tags":["Docker","Docker Compose"]},{"title":"Linux 基础 & LVM 磁盘扩容","url":"/2019/11/02/Linux 基础 & LVM 磁盘扩容/","content":"\n### 下载、安装Ubuntu  \n> 官网下载：https://ubuntu.com/download/server  \n\n### Linux目录结构  \n\n| 目录   | 说明                                       |\n|------|------------------------------------------|\n| **bin**  | 存放二进制可执行文件\\(ls,cat,mkdir等\\)              |\n| boot | 存放用于系统引导时使用的各种文件                         |\n| dev  | 用于存放设备文件                                 |\n| **etc**  | 存放系统配置文件                                 |\n| **home** | 存放所有用户文件的根目录                             |\n| lib  | 存放跟文件系统中的程序运行所需要的共享库及内核模块                |\n| mnt  | 系统管理员安装临时文件系统的安装点                        |\n| opt  | 额外安装的可选应用程序包所放置的位置                       |\n| proc | 虚拟文件系统，存放当前内存的映射                         |\n| root | 超级用户目录                                   |\n| sbin | 存放二进制可执行文件，只有root才能访问                    |\n| tmp  | 用于存放各种临时文件                               |\n| **usr**  | 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 |\n| **var**  | 用于存放运行时需要改变数据的文件                         |\n\n### 修改数据源  \n\n```\n# 查看系统版本\nlsb_release -a\n# 编辑数据源  \nvi /etc/apt/sources.list\n## 删除全部内容，添加  \ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\n# 更新数据源\napt-get update\n```\n\n### LVM的基本概念  \n#### 物理卷 Physical volume（PV）\n> 可以在上面建立卷组的媒介，可以是**硬盘分区**，也可以是**硬盘本身**或者**回环文件**（loopback file）。物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents）  \n\n#### 卷组 Volume group (VG)  \n> 将一组物理卷收集为一个**管理单元**  \n\n#### 逻辑卷 Logical volume (LV)  \n> **虚拟分区**，由物理区域（physical extents）组成  \n\n#### 物理区域 Physical extent (PE)\n> 硬盘可供指派给逻辑卷的最小单位（通常为 4MB）  \n\n### 开始LVM扩容  \n\n```\n# 查看 fdisk\nfdisk -l  \n```\n\n![image](https://note.youdao.com/yws/api/personal/file/158366A2ECF241F38EF67284942E1B67?method=download&shareKey=03efad7f6657df0955557c96be683842)\n\n> 因为这台机器默认开启了 LVM，所以目前有一个 **extended** 分区和一个 **LVM** 分区，并且他们是完全重叠的。这是因为，LVM 分区作为一个虚拟的分区，完全占用了这个 extended 分区，原理图见下：  \n![image](https://note.youdao.com/yws/api/personal/file/4641A2265CDD4FCAA12DD369E1F9B6E3?method=download&shareKey=bb9a1f1d593a7653ab75f0d108755840)  \n> 因此，现在需要做的就是将 extended partition (sda2) 扩展到最大，然后创建一个新的 LVM logical partition (sda6)，用它来填满 sda2  \n\n#### 查看所有连接到电脑上的储存设备  \n\n```\nfdisk -l |grep '/dev'\n```\n\n**1 块磁盘效果图**  \n![image](https://note.youdao.com/yws/api/personal/file/E01530FE7C014C08B037D8757099FA4B?method=download&shareKey=109c7985d3cfdeca6dec59c97c58f3fb)\n\n**2 块磁盘效果图**\n![image](https://note.youdao.com/yws/api/personal/file/474A8AA4FF1442CF948E14453A3BD1CB?method=download&shareKey=2f3b44b4c0ce214376481b1ed57cba36)\n\n#### 创建 sdb 分区  \n\n```\nfdisk /dev/sdb\nn\t# 新建分区\nl\t# 选择逻辑分区，如果没有，则首先创建扩展分区（p），然后再添加逻辑分区（硬盘：最多四个分区 P-P-P-P 或 P-P-P-E）\n# 格式化磁盘  \nmkfs -t ext4 /dev/sdb1\n# 创建 PV  \npvcreate /dev/sdb1\n# 查看卷组\npvscan\n# 扩容 VG\nvgdisplay\nvgextend ubuntu-vg /dev/sdb1\n# 增加指定大小\nlvextend -L +30G /dev/ubuntu-vg/root\n# 按百分比扩容\nlvextend -l +100%FREE /dev/ubuntu-vg/root\n# 刷新分区\nresize2fs /dev/ubuntu-vg/root\n# 删除 unknown device\npvscan\nvgreduce --removemissing ubuntu-vg\n```\n\n\n","tags":["Linux","Ubuntu","LVM"]},{"title":"GitFlow 工作流","url":"/2019/10/30/GitFlow 工作流/","content":"### Tortoise Git  \n> 官网下载：https://tortoisegit.org/download/  \n\n### Git几种主流的工作流\n#### 集中式工作流  \n> 所有的**功能开发与修改都在 master 分支上进行**的。开发者开始先克隆中央仓库。在自己的项目拷贝中像SVN一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。  \n![image](https://note.youdao.com/yws/api/personal/file/64CEFF1425774282A82F1E00D0FA8649?method=download&shareKey=5833170a020b4bb4651c41f983e47b37)  \n\n#### 功能分支工作流  \n> 功能分支工作流以集中式工作流为基础，不同的是**为各个新功能分配一个专门的分支来开发**。功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在 master 分支上。  \n![image](https://note.youdao.com/yws/api/personal/file/B1701B5FAB8140FEA44B3AD7372F114E?method=download&shareKey=c879c215afd63fdabfb4884b11cb9124)  \n\n#### GitFlow 工作流  \n> GitFlow 工作流通过为**功能开发、发布准备**和**维护分配**独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。\n![image](https://note.youdao.com/yws/api/personal/file/FB06F01E87C044949FABB9CDDE711F87?method=download&shareKey=a8fe1902c3daa4a33ea992469f5fa276)\n\n#### Forking 工作流  \n> Forking 工作流是分布式工作流，充分利用了 Git 在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。  \n![image](https://note.youdao.com/yws/api/personal/file/C89D9EEB7E08493380A8964FE4424739?method=download&shareKey=432315df4ddd4ba6ae44d3ee9af5724a)\n\n#### 流程解析  \n\n- **master分支：** 存放所有**正式发布的版本**，可以作为项目**历史版本记录分支**，不直接提交代码。仅用于保持一个对应线上运行代码的 code base。\n- **develop分支：** 为**主开发分支**，一般不直接提交代码  \n- **feature分支：** 为**新功能分支**，feature分支都是基于develop创建的，开发完成后会合并到develop分支上。\n- **release分支：** 为**发布分支**，基于最新develop分支创建。\n- **hotfix分支：** **基于master分支创建**，对线上版本的**bug进行修复**，完成后直接合并到master分支和develop分支，如果当前还有新功能release分支，也同步到release分支上。","tags":["GitFlow 工作流","Tortoise Git"]},{"title":"REST架构以及RESTful？","url":"/2019/10/28/REST架构以及RESTful？/","content":"### 介绍  \n#### 什么是REST？  \n> **REST（Representational State Transfer）** 表象化状态转变（表述性状态转变），在2000年被提出，基于HTTP、URI、XML、JSON等标准和协议，支持**轻量级、跨平台、跨语言**的架构设计。是Web服务的一种新的**架构风格**（一种思想）。 \n\n#### REST架构的主要原则  \n- 对网络上所有的资源都有一个**资源标志符**。\n- 对资源的操作**不会**改变标识符。\n- 同一资源有多种表现形式（xml、json）\n- 所有操作都是**无状态**的（Stateless） \n\n> **无状态性：** 使得客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前的请求，不需了解请求的历史。可以更容易的释放资源，让服务器利用Pool（连接池）技术来提高稳定性和性能。  \n\n#### 什么是RESTful风格？\n> RESTful是一种常见的**REST应用**，是遵循REST风格的**web服务**，REST式的web服务是一种ROA（面向资源的架构）。 \n\n### API设计  \n#### 设计原则  \n- URI 不能包含动词，只能是名词  \n> 形容词也是可以使用的，但是尽量少用  \n- API 的名词要以复数进行命名  \n- 命名名词的时候，要使用小写、数字及下划线来区分多个单词  \n> 样的设计是为了与 json 对象及属性的命名方案保持一致  \n#### 请求方式\n\n| http方法 | 资源操作   | 幂等 | 安全 |\n|--------|--------|----|----|\n| GET    | SELECT | 是  | 是  |\n| POST   | INSERT | 否  | 否  |\n| PUT    | UPDATE | 是  | 否  |\n| DELETE | DELETE | 是  | 否  |\n\n#### 状态码  \n\n| 状态码 | 描述      |\n|-----|---------|\n| 200 | 请求成功    |\n| 201 | 创建成功    |\n| 400 | 错误的请求   |\n| 401 | 未验证     |\n| 403 | 被拒绝     |\n| 404 | 无法找到    |\n| 409 | 资源冲突    |\n| 500 | 服务器内部错误 |\n\n#### 请求参数  \n- **对请求参数进行限制说明，写明参数要求**\n```\n【POST】     /v1/users                             // 创建用户信息\n请求内容\n{\n    \"username\": \"Tooi\",                 // 必填, 用户名称, max 20\n    \"password\": \"123456\",              // 必填, 用户密码, max 20\n    \"email\": \"tooi997@163.com\",     // 选填, 电子邮箱, max 32\n    \"sex\": 1                           // 必填, 用户性别[1-男 2-女 99-未知]\n}\n```\n\n#### 响应参数\n- **单条数据，直接返回json**\n\n```\nHTTP/1.1 200 OK\n{\n    \"id\" : \"01\",\n    \"name\" : \"Tooi6\",\n    \"created_time\": 2019-10-26,\n    \"updated_time\": 2019-10-26,\n    ...\n}\n```\n\n- 多条数据，封装结构体\n\n```\nHTTP/1.1 200 OK\n{\n    \"count\":100,\n    \"items\":[\n        {\n            \"id\" : \"01\",\n            \"name\" : \"Tooi6\",\n            \"created_time\": 2019-10-26,\n            \"updated_time\": 2019-10-26,\n            ...\n        },\n        ...\n    ]\n}\n```\n\n\n#### 异常响应  \n\n```\nHTTP/1.1 400 Bad Request\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n```  \n\n\n\n","tags":["RESTful","架构风格"]},{"title":"Validation（jQuery+Spring）","url":"/2019/10/28/Validation（jQuery+Spring）/","content":"\n### jQuery Validation  \n> jQuery Validation 前端表单验证框架  \n下载：https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.1    \n官方文档：https://jqueryvalidation.org/documentation/  \n\n#### DEMO  \n> 来源：https://www.runoob.com/jquery/jquery-plugin-validate.html\n\n```\n#引入js  \n<!-- jQuery Validation 1.14.0 -->\n<script src=\"../assets/jquery-validation-1.14.0/lib/jquery.js\"></script>\n<script src=\"../assets/jquery-validation-1.14.0/dist/jquery.validate.min.js\"></script>\n<script src=\"../assets/jquery-validation-1.14.0/dist/localization/messages_zh.js\"></script>\n\n#初始化脚本\n<script>\n$.validator.setDefaults({\n    submitHandler: function() {\n      alert(\"提交事件!\");\n    }\n});\n$().ready(function() {\n    $(\"#commentForm\").validate();\n});\n</script>\n\n#引入规则\n<form class=\"cmxform\" id=\"commentForm\" method=\"get\" action=\"\">\n  <fieldset>\n    <legend>输入您的名字，邮箱，URL，备注。</legend>\n    <p>\n      <label for=\"cname\">Name (必需, 最小两个字母)</label>\n      <input id=\"cname\" name=\"name\" minlength=\"2\" type=\"text\" required>\n    </p>\n    <p>\n      <label for=\"cemail\">E-Mail (必需)</label>\n      <input id=\"cemail\" type=\"email\" name=\"email\" required>\n    </p>\n    <p>\n      <label for=\"curl\">URL (可选)</label>\n      <input id=\"curl\" type=\"url\" name=\"url\">\n    </p>\n    <p>\n      <label for=\"ccomment\">备注 (必需)</label>\n      <textarea id=\"ccomment\" name=\"comment\" required></textarea>\n    </p>\n    <p>\n      <input class=\"submit\" type=\"submit\" value=\"Submit\">\n    </p>\n  </fieldset>\n</form>\n```\n\n### Spring Validation  \n> 官方文档：https://spring.io/guides/gs/validating-form-input/  \n\n#### DEMO  \n\n```\n#pom.xml  \n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>5.3.4.Final</version>\n</dependency>\n\n#定义工具类\n/**\n * JSR303 Validator(Hibernate Validator)工具类.\n * <p>\n * ConstraintViolation 中包含 propertyPath, message 和 invalidValue 等信息.\n * 提供了各种 convert 方法，适合不同的 i18n 需求:\n * 1. List<String>, String 内容为 message\n * 2. List<String>, String 内容为 propertyPath + separator + message\n * 3. Map<propertyPath, message>\n * <p>\n * 详情见wiki: https://github.com/springside/springside4/wiki/HibernateValidator\n *\n * <p>Title: BeanValidator</p>\n * <p>Description: </p>\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/26 17:21\n */\npublic class BeanValidator {\n\n    @Autowired\n    private static Validator validator;\n\n    public static void setValidator(Validator validator) {\n        BeanValidator.validator = validator;\n    }\n\n    /**\n     * 调用 JSR303 的 validate 方法, 验证失败时抛出 ConstraintViolationException.\n     */\n    private static void validateWithException(Validator validator, Object object, Class<?>... groups) throws ConstraintViolationException {\n        Set constraintViolations = validator.validate(object, groups);\n        if (!constraintViolations.isEmpty()) {\n            throw new ConstraintViolationException(constraintViolations);\n        }\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 中为 List<message>.\n     */\n    private static List<String> extractMessage(ConstraintViolationException e) {\n        return extractMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 List<message>\n     */\n    private static List<String> extractMessage(Set<? extends ConstraintViolation> constraintViolations) {\n        List<String> errorMessages = new ArrayList<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 Map<property, message>.\n     */\n    private static Map<String, String> extractPropertyAndMessage(ConstraintViolationException e) {\n        return extractPropertyAndMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 Map<property, message>.\n     */\n    private static Map<String, String> extractPropertyAndMessage(Set<? extends ConstraintViolation> constraintViolations) {\n        Map<String, String> errorMessages = new HashMap<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.put(violation.getPropertyPath().toString(), violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 List<propertyPath message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(ConstraintViolationException e) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), \" \");\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolations> 为 List<propertyPath message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(Set<? extends ConstraintViolation> constraintViolations) {\n        return extractPropertyAndMessageAsList(constraintViolations, \" \");\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 List<propertyPath + separator + message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(ConstraintViolationException e, String separator) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), separator);\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 List<propertyPath + separator + message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(Set<? extends ConstraintViolation> constraintViolations, String separator) {\n        List<String> errorMessages = new ArrayList<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getPropertyPath() + separator + violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 服务端参数有效性验证\n     *\n     * @param object 验证的实体对象\n     * @param groups 验证组\n     * @return 验证成功：返回 null；验证失败：返回错误信息\n     */\n    public static String validator(Object object, Class<?>... groups) {\n        try {\n            validateWithException(validator, object, groups);\n        } catch (ConstraintViolationException ex) {\n            List<String> list = extractMessage(ex);\n            list.add(0, \"数据验证失败：\");\n\n            // 封装错误消息为字符串\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < list.size(); i++) {\n                String exMsg = list.get(i);\n                if (i != 0 ){\n                    sb.append(String.format(\"%s. %s\", i, exMsg)).append(list.size() > 1 ? \"<br/>\" : \"\");\n                } else {\n                    sb.append(exMsg).append(list.size() > 1 ? \"<br/>\" : \"\");\n                }\n            }\n\n            return sb.toString();\n        }\n\n        return null;\n    }\n}\n\n#添加注解  \n@Length(min = 6, max = 20, message = \"用户名长度必须介于 6 和 20 之间\")\nprivate String username;\n\n#xml注入工具类 \n<!-- 配置 Bean Validator 定义 -->\n<bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/>\n<bean id=\"beanValidator\" class=\"com.funtl.my.shop.commons.validator.BeanValidator\">\n    <property name=\"validator\" ref=\"validator\" />\n</bean>\n```\n","tags":["Validation","jQuery","Spring"]},{"title":"使用Hexo+Github搭建博客","url":"/2018/12/01/使用Hexo+Github搭建博客/","content":"\n### 准备工作  \n- 创建仓库，创建一个名为 <你的用户名>.github.io 的仓库  \n- 安装软件  \n\n```\n# 下载、安装、配置 git\n官网下载：https://www.git-scm.com/download/   \n## 配置ssh key\n\n# 下载、安装 node.js  \nhttps://nodejs.org/en/download/ \n\n# 安装 hexo  \nnpm install -g hexo  \n```\n\n### 开始搭建  \n\n```\n# 初始化（必须在空文件夹内，使用git bash运行）  \nhexo init \n# 清理生成内容\nhexo clean \n# 生成\nhexo g \n# 启动服务\nhexo s  \n\n# 修改主题\n## 到官网下载主题 https://hexo.io/themes/  \n## 下载后解压到 themes 目录下  \n## 修改配置文件_config.yml  \n- theme: landscape\n+ theme: suka  \n\n# 上传到github\n## 配置_config.yml中deploy部分\ndeploy:\n  type: git\n  repository: git@github.com:Tooi6/Tooi6.github.io.git\n  branch: master  \n## 安装插件（不安装提示Deployer not found: git错误）\nnpm install hexo-deployer-git --save\n## 上传\nhexo d\n```\n\n### 常用的hexo命令  \n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\n```\n","tags":["Hexo","Github"]}]