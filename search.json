[{"title":"Docker 容器技术 & Docker Compose","url":"/2019/11/03/Docker 容器技术 & Docker Compose/","content":"\n### 简介\n#### 什么是Docker？  \n> Docker 是一个开源的**应用容器引擎**，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现**虚拟化**。容器是完全使用**沙箱机制**，相互之间不会有任何接口。  \n\n#### 虚拟机和容器的区别？  \n> **虚拟机：** 传统的虚拟机需要模拟整台机器包括硬件，每台虚拟机都需要有**自己的操作系统**，虚拟机一旦被开启，**预分配给它的资源将全部被占用**  \n\n> **容器：** 容器技术是和我们的宿主机**共享硬件资源及操作系统**，可以实现**资源的动态分配**。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以**分离的进程运行。**    \n\n#### 容器技术的优势  \n| 特性    | 容器        | 虚拟机    |\n|-------|-----------|--------|\n| 启动    | 秒级        | 分钟级    |\n| 硬盘使用  | 一般为MB     | 一般为GB  |\n| 性能    | 接近原生      | 弱于     |\n| 系统支持量 | 单机支持上千个容器 | 一般是几十个 |\n\n### Docker 的基本概念  \n- **镜像（Image）：** \n> Docker 镜像是一个**特殊的文件系统**，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。**镜像不包含任何动态数据，其内容在构建之后也不会被改变**\n- **容器（Container）：** \n> 容器的实质是**进程**，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个**隔离的环境**里，使用起来，就好像是在一个独立于宿主的系统下操作一样  \n\n**镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。**\n- **仓库（Repository）：**  \n\n> Docker 仓库是**集中存放镜像文件的场所**。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry (仓库注册服务器)就是这样的服务  \n 官方仓库：https://hub.docker.com/  \n \n- **Docker引擎**  \n> Docker 引擎是一个包含以下主要组件的客户端服务器应用程序（CS架构）。  \n**服务器(server)**，它是一种称为**守护进程**并且长时间(后台)运行的程序。  \n**REST API**，用于指定程序可以用来与守护进程通信的接口，并指示它做什么。  \n**客户端（Client）**，有命令行界面 (CLI) 工具  \n\n![image](https://note.youdao.com/yws/api/personal/file/851252360E394E6A8A63E181ED3E3203?method=download&shareKey=c1c71de21d8043aaa3d033697078fb02)\n\n### 如何使用？  \n#### 安装Docker \n\n```\n# 卸载旧版本  \nsudo apt-get autoremove docker docker-engine docker.io\n\n# 使用APT安装  \nsudo apt-get update \n## 安装必要的工具\nsudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common  \n## 安装 GPG 证书\ncurl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -  \n## 写入软件源信息  \nsudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"  \n## 更新并安装 \nsudo apt-get -y update\nsudo apt-get -y install docker-ce\n\n# 使用脚本自动安装（推荐）  \ncurl -fsSL get.docker.com -o get-docker.sh\nsudo sh get-docker.sh --mirror Aliyun\n\n# 启动 Docker CE\nsudo systemctl enable docker\nsudo systemctl start docker\n\n# 添加docker用户组  \ngroupadd docker    # 一般脚本已经建好了\nusermod -aG docker $USER\n\n# 运行hello-world\ndocker run hello-world\n```\n\n#### 配置镜像加速  \n\n```\nvim /etc/docker/daemon.json  # 没有则新建\n## 写入内容\n{\n  \"registry-mirrors\": [\n    \"https://registry.docker-cn.com\"\n  ]\n}\n```\n\n#### 基本操作  \n```\n# 下载镜像  \ndocker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] \n#下载tomcat镜像，默认下载官方的latest标签\ndocker pull tomcat   \n\n# 查看本地镜像  \ndocker images\n\n# 运行镜像  \ndocker run -d -p 8080:8080 tomcat  # -d:后台运行 -p:绑定端口 \n# 查看容器  \ndocker ps\n# 停止容器  \ndocker stop [NAME]\n# 其他命令\nhttps://www.runoob.com/docker/docker-command-manual.html\n```\n\n### 使用 Dockerfile 定制镜像\n#### demo：\n\n```\n# 创建Dockerfile\nFORM tomcat\nWORKDIR /usr/local/tomcat/webapps/ROOT/\nRUN \"hello Dockerfile\" > index.html\n\n# 构建镜像  \ndocker build -t mytomcat .\n\n# 运行  \ndocker run -p 80:8080 mytomcat bash  \n```\n\n#### 镜像构建上下文（Context）  \n> https://blog.csdn.net/small_to_large/article/details/77435541  \n\n#### Dockerfile 指令  \n> 官方文档：https://docs.docker.com/engine/reference/builder/\n\n### 使用数据卷构建MySQL  \n#### 什么是数据卷？  \n> 数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 **UFS**，可以提供很多有用的特性  \n- 数据卷 可以在**容器之间共享和重用**  \n- 对 数据卷 的**修改会立马生效**  \n- 对 数据卷 的**更新，不会影响镜像**  \n- 数据卷 默认会**一直存在**，即使容器被删除 **（MySQL可以用它来实现持久化）**\n\n#### 构建MySQL\n> 将本地文件加挂载到MySQL容器上，实现MySQL的持久化\n\n```\n# 拉取镜像  \ndocker pull mysql:5.7.28\n\n# 使用数据卷启动MySQL  \ndocker run -p 3306:3306 --name mysql \\\n-v /usr/local/docker/mysql/logs:/var/log/mysql \\\n-v /usr/local/docker/mysql/data:/var/lib/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-d mysql:5.7.28\n\n## 复制docker容器内容到宿主机  \ndocker cp mysql:/etc/mysql .  # 可以将MySQL配置负责到本地\n```\n\n### Docker Compose  \n#### 什么是 Docker Compose\n> Compose 项目是 Docker 官方的开源项目，负责实现**对 Docker 容器集群的快速编排。**    \nDocker Compose 它允许用户通过一个单独的 **docker-compose.yml** 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n\n#### 下载、安装  \n\n```\n# GitHub地址：https://github.com/docker/compose\n\n# 下载，并安装\ncurl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\n\n# 验证\ndocker-compose version\n\n# 卸载，直接删除二进制文件即可  \nrm /usr/local/bin/docker-compose\n```\n\n#### DEMO\n> \n\n```\n# 新建文件docker-compose.yml\n\n### 配置tomcat、MySQL\nversion: '3'\nservices:\n  tomcat:\n    restart: always\n    image: tomcat\n    container_name: tomcat\n    ports:\n      - 8080:8080\n    volumes:\n      - /usr/local/docker/tomcat/ROOT:/usr/local/tomcat/webapps/ROOT\n  mysql:\n    restart: always\n    image: mysql:5.7.22\n    container_name: mysql\n    ports:\n      - 3306:3306\n    environment:\n      TZ: Asia/Shanghai\n      MYSQL_ROOT_PASSWORD: 123456\n    command:\n      --character-set-server=utf8mb4\n      --collation-server=utf8mb4_general_ci\n      --explicit_defaults_for_timestamp=true\n      --lower_case_table_names=1\n      --max_allowed_packet=128M\n      --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"\n    volumes:\n      - mysql-data:/var/lib/mysql\n\nvolumes:\n  mysql-data:\n###\n```\n","tags":["Docker","Docker Compose"]},{"title":"Linux 基础 & LVM 磁盘扩容","url":"/2019/11/02/Linux 基础 & LVM 磁盘扩容/","content":"\n### 下载、安装Ubuntu  \n> 官网下载：https://ubuntu.com/download/server  \n\n### Linux目录结构  \n\n| 目录   | 说明                                       |\n|------|------------------------------------------|\n| **bin**  | 存放二进制可执行文件\\(ls,cat,mkdir等\\)              |\n| boot | 存放用于系统引导时使用的各种文件                         |\n| dev  | 用于存放设备文件                                 |\n| **etc**  | 存放系统配置文件                                 |\n| **home** | 存放所有用户文件的根目录                             |\n| lib  | 存放跟文件系统中的程序运行所需要的共享库及内核模块                |\n| mnt  | 系统管理员安装临时文件系统的安装点                        |\n| opt  | 额外安装的可选应用程序包所放置的位置                       |\n| proc | 虚拟文件系统，存放当前内存的映射                         |\n| root | 超级用户目录                                   |\n| sbin | 存放二进制可执行文件，只有root才能访问                    |\n| tmp  | 用于存放各种临时文件                               |\n| **usr**  | 用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录 |\n| **var**  | 用于存放运行时需要改变数据的文件                         |\n\n### 修改数据源  \n\n```\n# 查看系统版本\nlsb_release -a\n# 编辑数据源  \nvi /etc/apt/sources.list\n## 删除全部内容，添加  \ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\n# 更新数据源\napt-get update\n```\n\n### LVM的基本概念  \n#### 物理卷 Physical volume（PV）\n> 可以在上面建立卷组的媒介，可以是**硬盘分区**，也可以是**硬盘本身**或者**回环文件**（loopback file）。物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents）  \n\n#### 卷组 Volume group (VG)  \n> 将一组物理卷收集为一个**管理单元**  \n\n#### 逻辑卷 Logical volume (LV)  \n> **虚拟分区**，由物理区域（physical extents）组成  \n\n#### 物理区域 Physical extent (PE)\n> 硬盘可供指派给逻辑卷的最小单位（通常为 4MB）  \n\n### 开始LVM扩容  \n\n```\n# 查看 fdisk\nfdisk -l  \n```\n\n![image](https://note.youdao.com/yws/api/personal/file/158366A2ECF241F38EF67284942E1B67?method=download&shareKey=03efad7f6657df0955557c96be683842)\n\n> 因为这台机器默认开启了 LVM，所以目前有一个 **extended** 分区和一个 **LVM** 分区，并且他们是完全重叠的。这是因为，LVM 分区作为一个虚拟的分区，完全占用了这个 extended 分区，原理图见下：  \n![image](https://note.youdao.com/yws/api/personal/file/4641A2265CDD4FCAA12DD369E1F9B6E3?method=download&shareKey=bb9a1f1d593a7653ab75f0d108755840)  \n> 因此，现在需要做的就是将 extended partition (sda2) 扩展到最大，然后创建一个新的 LVM logical partition (sda6)，用它来填满 sda2  \n\n#### 查看所有连接到电脑上的储存设备  \n\n```\nfdisk -l |grep '/dev'\n```\n\n**1 块磁盘效果图**  \n![image](https://note.youdao.com/yws/api/personal/file/E01530FE7C014C08B037D8757099FA4B?method=download&shareKey=109c7985d3cfdeca6dec59c97c58f3fb)\n\n**2 块磁盘效果图**\n![image](https://note.youdao.com/yws/api/personal/file/474A8AA4FF1442CF948E14453A3BD1CB?method=download&shareKey=2f3b44b4c0ce214376481b1ed57cba36)\n\n#### 创建 sdb 分区  \n\n```\nfdisk /dev/sdb\nn\t# 新建分区\nl\t# 选择逻辑分区，如果没有，则首先创建扩展分区（p），然后再添加逻辑分区（硬盘：最多四个分区 P-P-P-P 或 P-P-P-E）\n# 格式化磁盘  \nmkfs -t ext4 /dev/sdb1\n# 创建 PV  \npvcreate /dev/sdb1\n# 查看卷组\npvscan\n# 扩容 VG\nvgdisplay\nvgextend ubuntu-vg /dev/sdb1\n# 增加指定大小\nlvextend -L +30G /dev/ubuntu-vg/root\n# 按百分比扩容\nlvextend -l +100%FREE /dev/ubuntu-vg/root\n# 刷新分区\nresize2fs /dev/ubuntu-vg/root\n# 删除 unknown device\npvscan\nvgreduce --removemissing ubuntu-vg\n```\n\n\n","tags":["Linux","Ubuntu","LVM"]},{"title":"GitFlow 工作流","url":"/2019/10/30/GitFlow 工作流/","content":"### Tortoise Git  \n> 官网下载：https://tortoisegit.org/download/  \n\n### Git几种主流的工作流\n#### 集中式工作流  \n> 所有的**功能开发与修改都在 master 分支上进行**的。开发者开始先克隆中央仓库。在自己的项目拷贝中像SVN一样的编辑文件和提交修改；但修改是存在本地的，和中央仓库是完全隔离的。开发者可以把和上游的同步延后到一个方便时间点。  \n![image](https://note.youdao.com/yws/api/personal/file/64CEFF1425774282A82F1E00D0FA8649?method=download&shareKey=5833170a020b4bb4651c41f983e47b37)  \n\n#### 功能分支工作流  \n> 功能分支工作流以集中式工作流为基础，不同的是**为各个新功能分配一个专门的分支来开发**。功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在 master 分支上。  \n![image](https://note.youdao.com/yws/api/personal/file/B1701B5FAB8140FEA44B3AD7372F114E?method=download&shareKey=c879c215afd63fdabfb4884b11cb9124)  \n\n#### GitFlow 工作流  \n> GitFlow 工作流通过为**功能开发、发布准备**和**维护分配**独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。\n![image](https://note.youdao.com/yws/api/personal/file/FB06F01E87C044949FABB9CDDE711F87?method=download&shareKey=a8fe1902c3daa4a33ea992469f5fa276)\n\n#### Forking 工作流  \n> Forking 工作流是分布式工作流，充分利用了 Git 在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。  \n![image](https://note.youdao.com/yws/api/personal/file/C89D9EEB7E08493380A8964FE4424739?method=download&shareKey=432315df4ddd4ba6ae44d3ee9af5724a)\n\n#### 流程解析  \n\n- **master分支：** 存放所有**正式发布的版本**，可以作为项目**历史版本记录分支**，不直接提交代码。仅用于保持一个对应线上运行代码的 code base。\n- **develop分支：** 为**主开发分支**，一般不直接提交代码  \n- **feature分支：** 为**新功能分支**，feature分支都是基于develop创建的，开发完成后会合并到develop分支上。\n- **release分支：** 为**发布分支**，基于最新develop分支创建。\n- **hotfix分支：** **基于master分支创建**，对线上版本的**bug进行修复**，完成后直接合并到master分支和develop分支，如果当前还有新功能release分支，也同步到release分支上。","tags":["GitFlow 工作流","Tortoise Git"]},{"title":"REST架构以及RESTful？","url":"/2019/10/28/REST架构以及RESTful？/","content":"### 介绍  \n#### 什么是REST？  \n> **REST（Representational State Transfer）** 表象化状态转变（表述性状态转变），在2000年被提出，基于HTTP、URI、XML、JSON等标准和协议，支持**轻量级、跨平台、跨语言**的架构设计。是Web服务的一种新的**架构风格**（一种思想）。 \n\n#### REST架构的主要原则  \n- 对网络上所有的资源都有一个**资源标志符**。\n- 对资源的操作**不会**改变标识符。\n- 同一资源有多种表现形式（xml、json）\n- 所有操作都是**无状态**的（Stateless） \n\n> **无状态性：** 使得客户端和服务器端不必保存对方的详细信息，服务器只需要处理当前的请求，不需了解请求的历史。可以更容易的释放资源，让服务器利用Pool（连接池）技术来提高稳定性和性能。  \n\n#### 什么是RESTful风格？\n> RESTful是一种常见的**REST应用**，是遵循REST风格的**web服务**，REST式的web服务是一种ROA（面向资源的架构）。 \n\n### API设计  \n#### 设计原则  \n- URI 不能包含动词，只能是名词  \n> 形容词也是可以使用的，但是尽量少用  \n- API 的名词要以复数进行命名  \n- 命名名词的时候，要使用小写、数字及下划线来区分多个单词  \n> 样的设计是为了与 json 对象及属性的命名方案保持一致  \n#### 请求方式\n\n| http方法 | 资源操作   | 幂等 | 安全 |\n|--------|--------|----|----|\n| GET    | SELECT | 是  | 是  |\n| POST   | INSERT | 否  | 否  |\n| PUT    | UPDATE | 是  | 否  |\n| DELETE | DELETE | 是  | 否  |\n\n#### 状态码  \n\n| 状态码 | 描述      |\n|-----|---------|\n| 200 | 请求成功    |\n| 201 | 创建成功    |\n| 400 | 错误的请求   |\n| 401 | 未验证     |\n| 403 | 被拒绝     |\n| 404 | 无法找到    |\n| 409 | 资源冲突    |\n| 500 | 服务器内部错误 |\n\n#### 请求参数  \n- **对请求参数进行限制说明，写明参数要求**\n```\n【POST】     /v1/users                             // 创建用户信息\n请求内容\n{\n    \"username\": \"Tooi\",                 // 必填, 用户名称, max 20\n    \"password\": \"123456\",              // 必填, 用户密码, max 20\n    \"email\": \"tooi997@163.com\",     // 选填, 电子邮箱, max 32\n    \"sex\": 1                           // 必填, 用户性别[1-男 2-女 99-未知]\n}\n```\n\n#### 响应参数\n- **单条数据，直接返回json**\n\n```\nHTTP/1.1 200 OK\n{\n    \"id\" : \"01\",\n    \"name\" : \"Tooi6\",\n    \"created_time\": 2019-10-26,\n    \"updated_time\": 2019-10-26,\n    ...\n}\n```\n\n- 多条数据，封装结构体\n\n```\nHTTP/1.1 200 OK\n{\n    \"count\":100,\n    \"items\":[\n        {\n            \"id\" : \"01\",\n            \"name\" : \"Tooi6\",\n            \"created_time\": 2019-10-26,\n            \"updated_time\": 2019-10-26,\n            ...\n        },\n        ...\n    ]\n}\n```\n\n\n#### 异常响应  \n\n```\nHTTP/1.1 400 Bad Request\nContent-Type: application/json\n{\n    \"code\": \"INVALID_ARGUMENT\",\n    \"message\": \"{error message}\",\n    \"cause\": \"{cause message}\",\n    \"request_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n    \"host_id\": \"{server identity}\",\n    \"server_time\": \"2014-01-01T12:00:00Z\"\n}\n```  \n\n\n\n","tags":["RESTful","架构风格"]},{"title":"Validation（jQuery+Spring）","url":"/2019/10/28/Validation（jQuery+Spring）/","content":"\n### jQuery Validation  \n> jQuery Validation 前端表单验证框架  \n下载：https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.1    \n官方文档：https://jqueryvalidation.org/documentation/  \n\n#### DEMO  \n> 来源：https://www.runoob.com/jquery/jquery-plugin-validate.html\n\n```\n#引入js  \n<!-- jQuery Validation 1.14.0 -->\n<script src=\"../assets/jquery-validation-1.14.0/lib/jquery.js\"></script>\n<script src=\"../assets/jquery-validation-1.14.0/dist/jquery.validate.min.js\"></script>\n<script src=\"../assets/jquery-validation-1.14.0/dist/localization/messages_zh.js\"></script>\n\n#初始化脚本\n<script>\n$.validator.setDefaults({\n    submitHandler: function() {\n      alert(\"提交事件!\");\n    }\n});\n$().ready(function() {\n    $(\"#commentForm\").validate();\n});\n</script>\n\n#引入规则\n<form class=\"cmxform\" id=\"commentForm\" method=\"get\" action=\"\">\n  <fieldset>\n    <legend>输入您的名字，邮箱，URL，备注。</legend>\n    <p>\n      <label for=\"cname\">Name (必需, 最小两个字母)</label>\n      <input id=\"cname\" name=\"name\" minlength=\"2\" type=\"text\" required>\n    </p>\n    <p>\n      <label for=\"cemail\">E-Mail (必需)</label>\n      <input id=\"cemail\" type=\"email\" name=\"email\" required>\n    </p>\n    <p>\n      <label for=\"curl\">URL (可选)</label>\n      <input id=\"curl\" type=\"url\" name=\"url\">\n    </p>\n    <p>\n      <label for=\"ccomment\">备注 (必需)</label>\n      <textarea id=\"ccomment\" name=\"comment\" required></textarea>\n    </p>\n    <p>\n      <input class=\"submit\" type=\"submit\" value=\"Submit\">\n    </p>\n  </fieldset>\n</form>\n```\n\n### Spring Validation  \n> 官方文档：https://spring.io/guides/gs/validating-form-input/  \n\n#### DEMO  \n\n```\n#pom.xml  \n<dependency>\n    <groupId>org.hibernate</groupId>\n    <artifactId>hibernate-validator</artifactId>\n    <version>5.3.4.Final</version>\n</dependency>\n\n#定义工具类\n/**\n * JSR303 Validator(Hibernate Validator)工具类.\n * <p>\n * ConstraintViolation 中包含 propertyPath, message 和 invalidValue 等信息.\n * 提供了各种 convert 方法，适合不同的 i18n 需求:\n * 1. List<String>, String 内容为 message\n * 2. List<String>, String 内容为 propertyPath + separator + message\n * 3. Map<propertyPath, message>\n * <p>\n * 详情见wiki: https://github.com/springside/springside4/wiki/HibernateValidator\n *\n * <p>Title: BeanValidator</p>\n * <p>Description: </p>\n *\n * @author Lusifer\n * @version 1.0.0\n * @date 2018/6/26 17:21\n */\npublic class BeanValidator {\n\n    @Autowired\n    private static Validator validator;\n\n    public static void setValidator(Validator validator) {\n        BeanValidator.validator = validator;\n    }\n\n    /**\n     * 调用 JSR303 的 validate 方法, 验证失败时抛出 ConstraintViolationException.\n     */\n    private static void validateWithException(Validator validator, Object object, Class<?>... groups) throws ConstraintViolationException {\n        Set constraintViolations = validator.validate(object, groups);\n        if (!constraintViolations.isEmpty()) {\n            throw new ConstraintViolationException(constraintViolations);\n        }\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 中为 List<message>.\n     */\n    private static List<String> extractMessage(ConstraintViolationException e) {\n        return extractMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 List<message>\n     */\n    private static List<String> extractMessage(Set<? extends ConstraintViolation> constraintViolations) {\n        List<String> errorMessages = new ArrayList<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 Map<property, message>.\n     */\n    private static Map<String, String> extractPropertyAndMessage(ConstraintViolationException e) {\n        return extractPropertyAndMessage(e.getConstraintViolations());\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 Map<property, message>.\n     */\n    private static Map<String, String> extractPropertyAndMessage(Set<? extends ConstraintViolation> constraintViolations) {\n        Map<String, String> errorMessages = new HashMap<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.put(violation.getPropertyPath().toString(), violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 List<propertyPath message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(ConstraintViolationException e) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), \" \");\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolations> 为 List<propertyPath message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(Set<? extends ConstraintViolation> constraintViolations) {\n        return extractPropertyAndMessageAsList(constraintViolations, \" \");\n    }\n\n    /**\n     * 辅助方法, 转换 ConstraintViolationException 中的 Set<ConstraintViolations> 为 List<propertyPath + separator + message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(ConstraintViolationException e, String separator) {\n        return extractPropertyAndMessageAsList(e.getConstraintViolations(), separator);\n    }\n\n    /**\n     * 辅助方法, 转换 Set<ConstraintViolation> 为 List<propertyPath + separator + message>.\n     */\n    private static List<String> extractPropertyAndMessageAsList(Set<? extends ConstraintViolation> constraintViolations, String separator) {\n        List<String> errorMessages = new ArrayList<>();\n        for (ConstraintViolation violation : constraintViolations) {\n            errorMessages.add(violation.getPropertyPath() + separator + violation.getMessage());\n        }\n        return errorMessages;\n    }\n\n    /**\n     * 服务端参数有效性验证\n     *\n     * @param object 验证的实体对象\n     * @param groups 验证组\n     * @return 验证成功：返回 null；验证失败：返回错误信息\n     */\n    public static String validator(Object object, Class<?>... groups) {\n        try {\n            validateWithException(validator, object, groups);\n        } catch (ConstraintViolationException ex) {\n            List<String> list = extractMessage(ex);\n            list.add(0, \"数据验证失败：\");\n\n            // 封装错误消息为字符串\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < list.size(); i++) {\n                String exMsg = list.get(i);\n                if (i != 0 ){\n                    sb.append(String.format(\"%s. %s\", i, exMsg)).append(list.size() > 1 ? \"<br/>\" : \"\");\n                } else {\n                    sb.append(exMsg).append(list.size() > 1 ? \"<br/>\" : \"\");\n                }\n            }\n\n            return sb.toString();\n        }\n\n        return null;\n    }\n}\n\n#添加注解  \n@Length(min = 6, max = 20, message = \"用户名长度必须介于 6 和 20 之间\")\nprivate String username;\n\n#xml注入工具类 \n<!-- 配置 Bean Validator 定义 -->\n<bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/>\n<bean id=\"beanValidator\" class=\"com.funtl.my.shop.commons.validator.BeanValidator\">\n    <property name=\"validator\" ref=\"validator\" />\n</bean>\n```\n","tags":["Validation","jQuery","Spring"]},{"title":"使用Hexo+Github搭建博客","url":"/2018/12/01/使用Hexo+Github搭建博客/","content":"\n### 准备工作  \n- 创建仓库，创建一个名为 <你的用户名>.github.io 的仓库  \n- 安装软件  \n\n```\n# 下载、安装、配置 git\n官网下载：https://www.git-scm.com/download/   \n## 配置ssh key\n\n# 下载、安装 node.js  \nhttps://nodejs.org/en/download/ \n\n# 安装 hexo  \nnpm install -g hexo  \n```\n\n### 开始搭建  \n\n```\n# 初始化（必须在空文件夹内，使用git bash运行）  \nhexo init \n# 清理生成内容\nhexo clean \n# 生成\nhexo g \n# 启动服务\nhexo s  \n\n# 修改主题\n## 到官网下载主题 https://hexo.io/themes/  \n## 下载后解压到 themes 目录下  \n## 修改配置文件_config.yml  \n- theme: landscape\n+ theme: suka  \n\n# 上传到github\n## 配置_config.yml中deploy部分\ndeploy:\n  type: git\n  repository: git@github.com:Tooi6/Tooi6.github.io.git\n  branch: master  \n## 安装插件（不安装提示Deployer not found: git错误）\nnpm install hexo-deployer-git --save\n## 上传\nhexo d\n```\n\n### 常用的hexo命令  \n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本\n```\n","tags":["Hexo","Github"]}]